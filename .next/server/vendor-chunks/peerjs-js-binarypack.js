"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/peerjs-js-binarypack";
exports.ids = ["vendor-chunks/peerjs-js-binarypack"];
exports.modules = {

/***/ "(ssr)/./node_modules/peerjs-js-binarypack/dist/binarypack.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/peerjs-js-binarypack/dist/binarypack.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Packer: () => (/* binding */ $0cfd7828ad59115f$export$b9ec4b114aa40074),\n/* harmony export */   pack: () => (/* binding */ $0cfd7828ad59115f$export$2a703dbb0cb35339),\n/* harmony export */   unpack: () => (/* binding */ $0cfd7828ad59115f$export$417857010dc9287f)\n/* harmony export */ });\nclass $e8379818650e2442$export$93654d4f2d6cd524 {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this._pieces = [];\n        this._parts = [];\n    }\n    append_buffer(data) {\n        this.flush();\n        this._parts.push(data);\n    }\n    append(data) {\n        this._pieces.push(data);\n    }\n    flush() {\n        if (this._pieces.length > 0) {\n            const buf = new Uint8Array(this._pieces);\n            this._parts.push(buf);\n            this._pieces = [];\n        }\n    }\n    toArrayBuffer() {\n        const buffer = [];\n        for (const part of this._parts)buffer.push(part);\n        return $e8379818650e2442$var$concatArrayBuffers(buffer).buffer;\n    }\n}\nfunction $e8379818650e2442$var$concatArrayBuffers(bufs) {\n    let size = 0;\n    for (const buf of bufs)size += buf.byteLength;\n    const result = new Uint8Array(size);\n    let offset = 0;\n    for (const buf of bufs){\n        const view = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n        result.set(view, offset);\n        offset += buf.byteLength;\n    }\n    return result;\n}\n\n\nfunction $0cfd7828ad59115f$export$417857010dc9287f(data) {\n    const unpacker = new $0cfd7828ad59115f$var$Unpacker(data);\n    return unpacker.unpack();\n}\nfunction $0cfd7828ad59115f$export$2a703dbb0cb35339(data) {\n    const packer = new $0cfd7828ad59115f$export$b9ec4b114aa40074();\n    const res = packer.pack(data);\n    if (res instanceof Promise) return res.then(()=>packer.getBuffer());\n    return packer.getBuffer();\n}\nclass $0cfd7828ad59115f$var$Unpacker {\n    constructor(data){\n        this.index = 0;\n        this.dataBuffer = data;\n        this.dataView = new Uint8Array(this.dataBuffer);\n        this.length = this.dataBuffer.byteLength;\n    }\n    unpack() {\n        const type = this.unpack_uint8();\n        if (type < 0x80) return type;\n        else if ((type ^ 0xe0) < 0x20) return (type ^ 0xe0) - 0x20;\n        let size;\n        if ((size = type ^ 0xa0) <= 0x0f) return this.unpack_raw(size);\n        else if ((size = type ^ 0xb0) <= 0x0f) return this.unpack_string(size);\n        else if ((size = type ^ 0x90) <= 0x0f) return this.unpack_array(size);\n        else if ((size = type ^ 0x80) <= 0x0f) return this.unpack_map(size);\n        switch(type){\n            case 0xc0:\n                return null;\n            case 0xc1:\n                return undefined;\n            case 0xc2:\n                return false;\n            case 0xc3:\n                return true;\n            case 0xca:\n                return this.unpack_float();\n            case 0xcb:\n                return this.unpack_double();\n            case 0xcc:\n                return this.unpack_uint8();\n            case 0xcd:\n                return this.unpack_uint16();\n            case 0xce:\n                return this.unpack_uint32();\n            case 0xcf:\n                return this.unpack_uint64();\n            case 0xd0:\n                return this.unpack_int8();\n            case 0xd1:\n                return this.unpack_int16();\n            case 0xd2:\n                return this.unpack_int32();\n            case 0xd3:\n                return this.unpack_int64();\n            case 0xd4:\n                return undefined;\n            case 0xd5:\n                return undefined;\n            case 0xd6:\n                return undefined;\n            case 0xd7:\n                return undefined;\n            case 0xd8:\n                size = this.unpack_uint16();\n                return this.unpack_string(size);\n            case 0xd9:\n                size = this.unpack_uint32();\n                return this.unpack_string(size);\n            case 0xda:\n                size = this.unpack_uint16();\n                return this.unpack_raw(size);\n            case 0xdb:\n                size = this.unpack_uint32();\n                return this.unpack_raw(size);\n            case 0xdc:\n                size = this.unpack_uint16();\n                return this.unpack_array(size);\n            case 0xdd:\n                size = this.unpack_uint32();\n                return this.unpack_array(size);\n            case 0xde:\n                size = this.unpack_uint16();\n                return this.unpack_map(size);\n            case 0xdf:\n                size = this.unpack_uint32();\n                return this.unpack_map(size);\n        }\n    }\n    unpack_uint8() {\n        const byte = this.dataView[this.index] & 0xff;\n        this.index++;\n        return byte;\n    }\n    unpack_uint16() {\n        const bytes = this.read(2);\n        const uint16 = (bytes[0] & 0xff) * 256 + (bytes[1] & 0xff);\n        this.index += 2;\n        return uint16;\n    }\n    unpack_uint32() {\n        const bytes = this.read(4);\n        const uint32 = ((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3];\n        this.index += 4;\n        return uint32;\n    }\n    unpack_uint64() {\n        const bytes = this.read(8);\n        const uint64 = ((((((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3]) * 256 + bytes[4]) * 256 + bytes[5]) * 256 + bytes[6]) * 256 + bytes[7];\n        this.index += 8;\n        return uint64;\n    }\n    unpack_int8() {\n        const uint8 = this.unpack_uint8();\n        return uint8 < 0x80 ? uint8 : uint8 - 256;\n    }\n    unpack_int16() {\n        const uint16 = this.unpack_uint16();\n        return uint16 < 0x8000 ? uint16 : uint16 - 65536;\n    }\n    unpack_int32() {\n        const uint32 = this.unpack_uint32();\n        return uint32 < 2 ** 31 ? uint32 : uint32 - 2 ** 32;\n    }\n    unpack_int64() {\n        const uint64 = this.unpack_uint64();\n        return uint64 < 2 ** 63 ? uint64 : uint64 - 2 ** 64;\n    }\n    unpack_raw(size) {\n        if (this.length < this.index + size) throw new Error(`BinaryPackFailure: index is out of range ${this.index} ${size} ${this.length}`);\n        const buf = this.dataBuffer.slice(this.index, this.index + size);\n        this.index += size;\n        return buf;\n    }\n    unpack_string(size) {\n        const bytes = this.read(size);\n        let i = 0;\n        let str = \"\";\n        let c;\n        let code;\n        while(i < size){\n            c = bytes[i];\n            // The length of a UTF-8 sequence is specified in the first byte:\n            // 0xxxxxxx means length 1,\n            // 110xxxxx means length 2,\n            // 1110xxxx means length 3,\n            // 11110xxx means length 4.\n            // 10xxxxxx is for non-initial bytes.\n            if (c < 0xa0) {\n                // One-byte sequence: bits 0xxxxxxx\n                code = c;\n                i++;\n            } else if ((c ^ 0xc0) < 0x20) {\n                // Two-byte sequence: bits 110xxxxx 10xxxxxx\n                code = (c & 0x1f) << 6 | bytes[i + 1] & 0x3f;\n                i += 2;\n            } else if ((c ^ 0xe0) < 0x10) {\n                // Three-byte sequence: bits 1110xxxx 10xxxxxx 10xxxxxx\n                code = (c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f;\n                i += 3;\n            } else {\n                // Four-byte sequence: bits 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n                code = (c & 0x07) << 18 | (bytes[i + 1] & 0x3f) << 12 | (bytes[i + 2] & 0x3f) << 6 | bytes[i + 3] & 0x3f;\n                i += 4;\n            }\n            str += String.fromCodePoint(code);\n        }\n        this.index += size;\n        return str;\n    }\n    unpack_array(size) {\n        const objects = new Array(size);\n        for(let i = 0; i < size; i++)objects[i] = this.unpack();\n        return objects;\n    }\n    unpack_map(size) {\n        const map = {};\n        for(let i = 0; i < size; i++){\n            const key = this.unpack();\n            map[key] = this.unpack();\n        }\n        return map;\n    }\n    unpack_float() {\n        const uint32 = this.unpack_uint32();\n        const sign = uint32 >> 31;\n        const exp = (uint32 >> 23 & 0xff) - 127;\n        const fraction = uint32 & 0x7fffff | 0x800000;\n        return (sign === 0 ? 1 : -1) * fraction * 2 ** (exp - 23);\n    }\n    unpack_double() {\n        const h32 = this.unpack_uint32();\n        const l32 = this.unpack_uint32();\n        const sign = h32 >> 31;\n        const exp = (h32 >> 20 & 0x7ff) - 1023;\n        const hfrac = h32 & 0xfffff | 0x100000;\n        const frac = hfrac * 2 ** (exp - 20) + l32 * 2 ** (exp - 52);\n        return (sign === 0 ? 1 : -1) * frac;\n    }\n    read(length) {\n        const j = this.index;\n        if (j + length <= this.length) return this.dataView.subarray(j, j + length);\n        else throw new Error(\"BinaryPackFailure: read index out of range\");\n    }\n}\nclass $0cfd7828ad59115f$export$b9ec4b114aa40074 {\n    getBuffer() {\n        return this._bufferBuilder.toArrayBuffer();\n    }\n    pack(value) {\n        if (typeof value === \"string\") this.pack_string(value);\n        else if (typeof value === \"number\") {\n            if (Math.floor(value) === value) this.pack_integer(value);\n            else this.pack_double(value);\n        } else if (typeof value === \"boolean\") {\n            if (value === true) this._bufferBuilder.append(0xc3);\n            else if (value === false) this._bufferBuilder.append(0xc2);\n        } else if (value === undefined) this._bufferBuilder.append(0xc0);\n        else if (typeof value === \"object\") {\n            if (value === null) this._bufferBuilder.append(0xc0);\n            else {\n                const constructor = value.constructor;\n                if (value instanceof Array) {\n                    const res = this.pack_array(value);\n                    if (res instanceof Promise) return res.then(()=>this._bufferBuilder.flush());\n                } else if (value instanceof ArrayBuffer) this.pack_bin(new Uint8Array(value));\n                else if (\"BYTES_PER_ELEMENT\" in value) {\n                    const v = value;\n                    this.pack_bin(new Uint8Array(v.buffer, v.byteOffset, v.byteLength));\n                } else if (value instanceof Date) this.pack_string(value.toString());\n                else if (value instanceof Blob) return value.arrayBuffer().then((buffer)=>{\n                    this.pack_bin(new Uint8Array(buffer));\n                    this._bufferBuilder.flush();\n                });\n                else if (constructor == Object || constructor.toString().startsWith(\"class\")) {\n                    const res = this.pack_object(value);\n                    if (res instanceof Promise) return res.then(()=>this._bufferBuilder.flush());\n                } else throw new Error(`Type \"${constructor.toString()}\" not yet supported`);\n            }\n        } else throw new Error(`Type \"${typeof value}\" not yet supported`);\n        this._bufferBuilder.flush();\n    }\n    pack_bin(blob) {\n        const length = blob.length;\n        if (length <= 0x0f) this.pack_uint8(0xa0 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xda);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xdb);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        this._bufferBuilder.append_buffer(blob);\n    }\n    pack_string(str) {\n        const encoded = this._textEncoder.encode(str);\n        const length = encoded.length;\n        if (length <= 0x0f) this.pack_uint8(0xb0 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xd8);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xd9);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        this._bufferBuilder.append_buffer(encoded);\n    }\n    pack_array(ary) {\n        const length = ary.length;\n        if (length <= 0x0f) this.pack_uint8(0x90 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xdc);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xdd);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        const packNext = (index)=>{\n            if (index < length) {\n                const res = this.pack(ary[index]);\n                if (res instanceof Promise) return res.then(()=>packNext(index + 1));\n                return packNext(index + 1);\n            }\n        };\n        return packNext(0);\n    }\n    pack_integer(num) {\n        if (num >= -32 && num <= 0x7f) this._bufferBuilder.append(num & 0xff);\n        else if (num >= 0x00 && num <= 0xff) {\n            this._bufferBuilder.append(0xcc);\n            this.pack_uint8(num);\n        } else if (num >= -128 && num <= 0x7f) {\n            this._bufferBuilder.append(0xd0);\n            this.pack_int8(num);\n        } else if (num >= 0x0000 && num <= 0xffff) {\n            this._bufferBuilder.append(0xcd);\n            this.pack_uint16(num);\n        } else if (num >= -32768 && num <= 0x7fff) {\n            this._bufferBuilder.append(0xd1);\n            this.pack_int16(num);\n        } else if (num >= 0x00000000 && num <= 0xffffffff) {\n            this._bufferBuilder.append(0xce);\n            this.pack_uint32(num);\n        } else if (num >= -2147483648 && num <= 0x7fffffff) {\n            this._bufferBuilder.append(0xd2);\n            this.pack_int32(num);\n        } else if (num >= -9223372036854776000 && num <= 0x7fffffffffffffff) {\n            this._bufferBuilder.append(0xd3);\n            this.pack_int64(num);\n        } else if (num >= 0x0000000000000000 && num <= 0xffffffffffffffff) {\n            this._bufferBuilder.append(0xcf);\n            this.pack_uint64(num);\n        } else throw new Error(\"Invalid integer\");\n    }\n    pack_double(num) {\n        let sign = 0;\n        if (num < 0) {\n            sign = 1;\n            num = -num;\n        }\n        const exp = Math.floor(Math.log(num) / Math.LN2);\n        const frac0 = num / 2 ** exp - 1;\n        const frac1 = Math.floor(frac0 * 2 ** 52);\n        const b32 = 2 ** 32;\n        const h32 = sign << 31 | exp + 1023 << 20 | frac1 / b32 & 0x0fffff;\n        const l32 = frac1 % b32;\n        this._bufferBuilder.append(0xcb);\n        this.pack_int32(h32);\n        this.pack_int32(l32);\n    }\n    pack_object(obj) {\n        const keys = Object.keys(obj);\n        const length = keys.length;\n        if (length <= 0x0f) this.pack_uint8(0x80 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xde);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xdf);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        const packNext = (index)=>{\n            if (index < keys.length) {\n                const prop = keys[index];\n                // eslint-disable-next-line no-prototype-builtins\n                if (obj.hasOwnProperty(prop)) {\n                    this.pack(prop);\n                    const res = this.pack(obj[prop]);\n                    if (res instanceof Promise) return res.then(()=>packNext(index + 1));\n                }\n                return packNext(index + 1);\n            }\n        };\n        return packNext(0);\n    }\n    pack_uint8(num) {\n        this._bufferBuilder.append(num);\n    }\n    pack_uint16(num) {\n        this._bufferBuilder.append(num >> 8);\n        this._bufferBuilder.append(num & 0xff);\n    }\n    pack_uint32(num) {\n        const n = num & 0xffffffff;\n        this._bufferBuilder.append((n & 0xff000000) >>> 24);\n        this._bufferBuilder.append((n & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((n & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(n & 0x000000ff);\n    }\n    pack_uint64(num) {\n        const high = num / 2 ** 32;\n        const low = num % 2 ** 32;\n        this._bufferBuilder.append((high & 0xff000000) >>> 24);\n        this._bufferBuilder.append((high & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((high & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(high & 0x000000ff);\n        this._bufferBuilder.append((low & 0xff000000) >>> 24);\n        this._bufferBuilder.append((low & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((low & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(low & 0x000000ff);\n    }\n    pack_int8(num) {\n        this._bufferBuilder.append(num & 0xff);\n    }\n    pack_int16(num) {\n        this._bufferBuilder.append((num & 0xff00) >> 8);\n        this._bufferBuilder.append(num & 0xff);\n    }\n    pack_int32(num) {\n        this._bufferBuilder.append(num >>> 24 & 0xff);\n        this._bufferBuilder.append((num & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((num & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(num & 0x000000ff);\n    }\n    pack_int64(num) {\n        const high = Math.floor(num / 2 ** 32);\n        const low = num % 2 ** 32;\n        this._bufferBuilder.append((high & 0xff000000) >>> 24);\n        this._bufferBuilder.append((high & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((high & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(high & 0x000000ff);\n        this._bufferBuilder.append((low & 0xff000000) >>> 24);\n        this._bufferBuilder.append((low & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((low & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(low & 0x000000ff);\n    }\n    constructor(){\n        this._bufferBuilder = new (0, $e8379818650e2442$export$93654d4f2d6cd524)();\n        this._textEncoder = new TextEncoder();\n    }\n}\n\n\n\n//# sourceMappingURL=binarypack.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGVlcmpzLWpzLWJpbmFyeXBhY2svZGlzdC9iaW5hcnlwYWNrLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsWUFBWSxFQUFFLE1BQU0sRUFBRSxZQUFZO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCLHVCQUF1QjtBQUN2RTtBQUNBLFVBQVUsOEJBQThCLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdxSztBQUNySyIsInNvdXJjZXMiOlsid2VicGFjazovL3NvdW5kYm9hcmQvLi9ub2RlX21vZHVsZXMvcGVlcmpzLWpzLWJpbmFyeXBhY2svZGlzdC9iaW5hcnlwYWNrLm1qcz80YjcyIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzICRlODM3OTgxODY1MGUyNDQyJGV4cG9ydCQ5MzY1NGQ0ZjJkNmNkNTI0IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgdGhpcy5fcGllY2VzID0gW107XG4gICAgICAgIHRoaXMuX3BhcnRzID0gW107XG4gICAgfVxuICAgIGFwcGVuZF9idWZmZXIoZGF0YSkge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuX3BhcnRzLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIGFwcGVuZChkYXRhKSB7XG4gICAgICAgIHRoaXMuX3BpZWNlcy5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BpZWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLl9waWVjZXMpO1xuICAgICAgICAgICAgdGhpcy5fcGFydHMucHVzaChidWYpO1xuICAgICAgICAgICAgdGhpcy5fcGllY2VzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9BcnJheUJ1ZmZlcigpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl9wYXJ0cylidWZmZXIucHVzaChwYXJ0KTtcbiAgICAgICAgcmV0dXJuICRlODM3OTgxODY1MGUyNDQyJHZhciRjb25jYXRBcnJheUJ1ZmZlcnMoYnVmZmVyKS5idWZmZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gJGU4Mzc5ODE4NjUwZTI0NDIkdmFyJGNvbmNhdEFycmF5QnVmZmVycyhidWZzKSB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIGZvciAoY29uc3QgYnVmIG9mIGJ1ZnMpc2l6ZSArPSBidWYuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGJ1ZiBvZiBidWZzKXtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlc3VsdC5zZXQodmlldywgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGJ1Zi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uICQwY2ZkNzgyOGFkNTkxMTVmJGV4cG9ydCQ0MTc4NTcwMTBkYzkyODdmKGRhdGEpIHtcbiAgICBjb25zdCB1bnBhY2tlciA9IG5ldyAkMGNmZDc4MjhhZDU5MTE1ZiR2YXIkVW5wYWNrZXIoZGF0YSk7XG4gICAgcmV0dXJuIHVucGFja2VyLnVucGFjaygpO1xufVxuZnVuY3Rpb24gJDBjZmQ3ODI4YWQ1OTExNWYkZXhwb3J0JDJhNzAzZGJiMGNiMzUzMzkoZGF0YSkge1xuICAgIGNvbnN0IHBhY2tlciA9IG5ldyAkMGNmZDc4MjhhZDU5MTE1ZiRleHBvcnQkYjllYzRiMTE0YWE0MDA3NCgpO1xuICAgIGNvbnN0IHJlcyA9IHBhY2tlci5wYWNrKGRhdGEpO1xuICAgIGlmIChyZXMgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gcmVzLnRoZW4oKCk9PnBhY2tlci5nZXRCdWZmZXIoKSk7XG4gICAgcmV0dXJuIHBhY2tlci5nZXRCdWZmZXIoKTtcbn1cbmNsYXNzICQwY2ZkNzgyOGFkNTkxMTVmJHZhciRVbnBhY2tlciB7XG4gICAgY29uc3RydWN0b3IoZGF0YSl7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmRhdGFCdWZmZXIgPSBkYXRhO1xuICAgICAgICB0aGlzLmRhdGFWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhQnVmZmVyKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGFCdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdW5wYWNrKCkge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy51bnBhY2tfdWludDgoKTtcbiAgICAgICAgaWYgKHR5cGUgPCAweDgwKSByZXR1cm4gdHlwZTtcbiAgICAgICAgZWxzZSBpZiAoKHR5cGUgXiAweGUwKSA8IDB4MjApIHJldHVybiAodHlwZSBeIDB4ZTApIC0gMHgyMDtcbiAgICAgICAgbGV0IHNpemU7XG4gICAgICAgIGlmICgoc2l6ZSA9IHR5cGUgXiAweGEwKSA8PSAweDBmKSByZXR1cm4gdGhpcy51bnBhY2tfcmF3KHNpemUpO1xuICAgICAgICBlbHNlIGlmICgoc2l6ZSA9IHR5cGUgXiAweGIwKSA8PSAweDBmKSByZXR1cm4gdGhpcy51bnBhY2tfc3RyaW5nKHNpemUpO1xuICAgICAgICBlbHNlIGlmICgoc2l6ZSA9IHR5cGUgXiAweDkwKSA8PSAweDBmKSByZXR1cm4gdGhpcy51bnBhY2tfYXJyYXkoc2l6ZSk7XG4gICAgICAgIGVsc2UgaWYgKChzaXplID0gdHlwZSBeIDB4ODApIDw9IDB4MGYpIHJldHVybiB0aGlzLnVucGFja19tYXAoc2l6ZSk7XG4gICAgICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgICAgIGNhc2UgMHhjMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgMHhjMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSAweGMyOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMHhjMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMHhjYTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfZmxvYXQoKTtcbiAgICAgICAgICAgIGNhc2UgMHhjYjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfZG91YmxlKCk7XG4gICAgICAgICAgICBjYXNlIDB4Y2M6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3VpbnQ4KCk7XG4gICAgICAgICAgICBjYXNlIDB4Y2Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgICAgICAgICAgY2FzZSAweGNlOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgICAgICAgIGNhc2UgMHhjZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfdWludDY0KCk7XG4gICAgICAgICAgICBjYXNlIDB4ZDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2ludDgoKTtcbiAgICAgICAgICAgIGNhc2UgMHhkMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50MTYoKTtcbiAgICAgICAgICAgIGNhc2UgMHhkMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50MzIoKTtcbiAgICAgICAgICAgIGNhc2UgMHhkMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50NjQoKTtcbiAgICAgICAgICAgIGNhc2UgMHhkNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSAweGQ1OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIDB4ZDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhc2UgMHhkNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSAweGQ4OlxuICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MTYoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfc3RyaW5nKHNpemUpO1xuICAgICAgICAgICAgY2FzZSAweGQ5OlxuICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfc3RyaW5nKHNpemUpO1xuICAgICAgICAgICAgY2FzZSAweGRhOlxuICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MTYoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfcmF3KHNpemUpO1xuICAgICAgICAgICAgY2FzZSAweGRiOlxuICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfcmF3KHNpemUpO1xuICAgICAgICAgICAgY2FzZSAweGRjOlxuICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MTYoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfYXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICBjYXNlIDB4ZGQ6XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19hcnJheShzaXplKTtcbiAgICAgICAgICAgIGNhc2UgMHhkZTpcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX21hcChzaXplKTtcbiAgICAgICAgICAgIGNhc2UgMHhkZjpcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX21hcChzaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnBhY2tfdWludDgoKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSB0aGlzLmRhdGFWaWV3W3RoaXMuaW5kZXhdICYgMHhmZjtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gYnl0ZTtcbiAgICB9XG4gICAgdW5wYWNrX3VpbnQxNigpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnJlYWQoMik7XG4gICAgICAgIGNvbnN0IHVpbnQxNiA9IChieXRlc1swXSAmIDB4ZmYpICogMjU2ICsgKGJ5dGVzWzFdICYgMHhmZik7XG4gICAgICAgIHRoaXMuaW5kZXggKz0gMjtcbiAgICAgICAgcmV0dXJuIHVpbnQxNjtcbiAgICB9XG4gICAgdW5wYWNrX3VpbnQzMigpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnJlYWQoNCk7XG4gICAgICAgIGNvbnN0IHVpbnQzMiA9ICgoYnl0ZXNbMF0gKiAyNTYgKyBieXRlc1sxXSkgKiAyNTYgKyBieXRlc1syXSkgKiAyNTYgKyBieXRlc1szXTtcbiAgICAgICAgdGhpcy5pbmRleCArPSA0O1xuICAgICAgICByZXR1cm4gdWludDMyO1xuICAgIH1cbiAgICB1bnBhY2tfdWludDY0KCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMucmVhZCg4KTtcbiAgICAgICAgY29uc3QgdWludDY0ID0gKCgoKCgoYnl0ZXNbMF0gKiAyNTYgKyBieXRlc1sxXSkgKiAyNTYgKyBieXRlc1syXSkgKiAyNTYgKyBieXRlc1szXSkgKiAyNTYgKyBieXRlc1s0XSkgKiAyNTYgKyBieXRlc1s1XSkgKiAyNTYgKyBieXRlc1s2XSkgKiAyNTYgKyBieXRlc1s3XTtcbiAgICAgICAgdGhpcy5pbmRleCArPSA4O1xuICAgICAgICByZXR1cm4gdWludDY0O1xuICAgIH1cbiAgICB1bnBhY2tfaW50OCgpIHtcbiAgICAgICAgY29uc3QgdWludDggPSB0aGlzLnVucGFja191aW50OCgpO1xuICAgICAgICByZXR1cm4gdWludDggPCAweDgwID8gdWludDggOiB1aW50OCAtIDI1NjtcbiAgICB9XG4gICAgdW5wYWNrX2ludDE2KCkge1xuICAgICAgICBjb25zdCB1aW50MTYgPSB0aGlzLnVucGFja191aW50MTYoKTtcbiAgICAgICAgcmV0dXJuIHVpbnQxNiA8IDB4ODAwMCA/IHVpbnQxNiA6IHVpbnQxNiAtIDY1NTM2O1xuICAgIH1cbiAgICB1bnBhY2tfaW50MzIoKSB7XG4gICAgICAgIGNvbnN0IHVpbnQzMiA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgICByZXR1cm4gdWludDMyIDwgMiAqKiAzMSA/IHVpbnQzMiA6IHVpbnQzMiAtIDIgKiogMzI7XG4gICAgfVxuICAgIHVucGFja19pbnQ2NCgpIHtcbiAgICAgICAgY29uc3QgdWludDY0ID0gdGhpcy51bnBhY2tfdWludDY0KCk7XG4gICAgICAgIHJldHVybiB1aW50NjQgPCAyICoqIDYzID8gdWludDY0IDogdWludDY0IC0gMiAqKiA2NDtcbiAgICB9XG4gICAgdW5wYWNrX3JhdyhzaXplKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IHRoaXMuaW5kZXggKyBzaXplKSB0aHJvdyBuZXcgRXJyb3IoYEJpbmFyeVBhY2tGYWlsdXJlOiBpbmRleCBpcyBvdXQgb2YgcmFuZ2UgJHt0aGlzLmluZGV4fSAke3NpemV9ICR7dGhpcy5sZW5ndGh9YCk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuZGF0YUJ1ZmZlci5zbGljZSh0aGlzLmluZGV4LCB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgdW5wYWNrX3N0cmluZyhzaXplKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5yZWFkKHNpemUpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICBsZXQgYztcbiAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgIHdoaWxlKGkgPCBzaXplKXtcbiAgICAgICAgICAgIGMgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIFRoZSBsZW5ndGggb2YgYSBVVEYtOCBzZXF1ZW5jZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGZpcnN0IGJ5dGU6XG4gICAgICAgICAgICAvLyAweHh4eHh4eCBtZWFucyBsZW5ndGggMSxcbiAgICAgICAgICAgIC8vIDExMHh4eHh4IG1lYW5zIGxlbmd0aCAyLFxuICAgICAgICAgICAgLy8gMTExMHh4eHggbWVhbnMgbGVuZ3RoIDMsXG4gICAgICAgICAgICAvLyAxMTExMHh4eCBtZWFucyBsZW5ndGggNC5cbiAgICAgICAgICAgIC8vIDEweHh4eHh4IGlzIGZvciBub24taW5pdGlhbCBieXRlcy5cbiAgICAgICAgICAgIGlmIChjIDwgMHhhMCkge1xuICAgICAgICAgICAgICAgIC8vIE9uZS1ieXRlIHNlcXVlbmNlOiBiaXRzIDB4eHh4eHh4XG4gICAgICAgICAgICAgICAgY29kZSA9IGM7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoYyBeIDB4YzApIDwgMHgyMCkge1xuICAgICAgICAgICAgICAgIC8vIFR3by1ieXRlIHNlcXVlbmNlOiBiaXRzIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICAgICAgY29kZSA9IChjICYgMHgxZikgPDwgNiB8IGJ5dGVzW2kgKyAxXSAmIDB4M2Y7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoYyBeIDB4ZTApIDwgMHgxMCkge1xuICAgICAgICAgICAgICAgIC8vIFRocmVlLWJ5dGUgc2VxdWVuY2U6IGJpdHMgMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgICAgICBjb2RlID0gKGMgJiAweDBmKSA8PCAxMiB8IChieXRlc1tpICsgMV0gJiAweDNmKSA8PCA2IHwgYnl0ZXNbaSArIDJdICYgMHgzZjtcbiAgICAgICAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvdXItYnl0ZSBzZXF1ZW5jZTogYml0cyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICAgIGNvZGUgPSAoYyAmIDB4MDcpIDw8IDE4IHwgKGJ5dGVzW2kgKyAxXSAmIDB4M2YpIDw8IDEyIHwgKGJ5dGVzW2kgKyAyXSAmIDB4M2YpIDw8IDYgfCBieXRlc1tpICsgM10gJiAweDNmO1xuICAgICAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHVucGFja19hcnJheShzaXplKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdHMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspb2JqZWN0c1tpXSA9IHRoaXMudW5wYWNrKCk7XG4gICAgICAgIHJldHVybiBvYmplY3RzO1xuICAgIH1cbiAgICB1bnBhY2tfbWFwKHNpemUpIHtcbiAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy51bnBhY2soKTtcbiAgICAgICAgICAgIG1hcFtrZXldID0gdGhpcy51bnBhY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICB1bnBhY2tfZmxvYXQoKSB7XG4gICAgICAgIGNvbnN0IHVpbnQzMiA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgICBjb25zdCBzaWduID0gdWludDMyID4+IDMxO1xuICAgICAgICBjb25zdCBleHAgPSAodWludDMyID4+IDIzICYgMHhmZikgLSAxMjc7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uID0gdWludDMyICYgMHg3ZmZmZmYgfCAweDgwMDAwMDtcbiAgICAgICAgcmV0dXJuIChzaWduID09PSAwID8gMSA6IC0xKSAqIGZyYWN0aW9uICogMiAqKiAoZXhwIC0gMjMpO1xuICAgIH1cbiAgICB1bnBhY2tfZG91YmxlKCkge1xuICAgICAgICBjb25zdCBoMzIgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgICAgY29uc3QgbDMyID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gICAgICAgIGNvbnN0IHNpZ24gPSBoMzIgPj4gMzE7XG4gICAgICAgIGNvbnN0IGV4cCA9IChoMzIgPj4gMjAgJiAweDdmZikgLSAxMDIzO1xuICAgICAgICBjb25zdCBoZnJhYyA9IGgzMiAmIDB4ZmZmZmYgfCAweDEwMDAwMDtcbiAgICAgICAgY29uc3QgZnJhYyA9IGhmcmFjICogMiAqKiAoZXhwIC0gMjApICsgbDMyICogMiAqKiAoZXhwIC0gNTIpO1xuICAgICAgICByZXR1cm4gKHNpZ24gPT09IDAgPyAxIDogLTEpICogZnJhYztcbiAgICB9XG4gICAgcmVhZChsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaiA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGlmIChqICsgbGVuZ3RoIDw9IHRoaXMubGVuZ3RoKSByZXR1cm4gdGhpcy5kYXRhVmlldy5zdWJhcnJheShqLCBqICsgbGVuZ3RoKTtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJCaW5hcnlQYWNrRmFpbHVyZTogcmVhZCBpbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfVxufVxuY2xhc3MgJDBjZmQ3ODI4YWQ1OTExNWYkZXhwb3J0JGI5ZWM0YjExNGFhNDAwNzQge1xuICAgIGdldEJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlckJ1aWxkZXIudG9BcnJheUJ1ZmZlcigpO1xuICAgIH1cbiAgICBwYWNrKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHRoaXMucGFja19zdHJpbmcodmFsdWUpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUpIHRoaXMucGFja19pbnRlZ2VyKHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5wYWNrX2RvdWJsZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGMzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSkgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjMik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjMCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGMwKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5wYWNrX2FycmF5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiByZXMudGhlbigoKT0+dGhpcy5fYnVmZmVyQnVpbGRlci5mbHVzaCgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHRoaXMucGFja19iaW4obmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcIkJZVEVTX1BFUl9FTEVNRU5UXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2tfYmluKG5ldyBVaW50OEFycmF5KHYuYnVmZmVyLCB2LmJ5dGVPZmZzZXQsIHYuYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB0aGlzLnBhY2tfc3RyaW5nKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikgcmV0dXJuIHZhbHVlLmFycmF5QnVmZmVyKCkudGhlbigoYnVmZmVyKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2tfYmluKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc3RydWN0b3IgPT0gT2JqZWN0IHx8IGNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuc3RhcnRzV2l0aChcImNsYXNzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMucGFja19vYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHJlcy50aGVuKCgpPT50aGlzLl9idWZmZXJCdWlsZGVyLmZsdXNoKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgXCIke2NvbnN0cnVjdG9yLnRvU3RyaW5nKCl9XCIgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihgVHlwZSBcIiR7dHlwZW9mIHZhbHVlfVwiIG5vdCB5ZXQgc3VwcG9ydGVkYCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuZmx1c2goKTtcbiAgICB9XG4gICAgcGFja19iaW4oYmxvYikge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBibG9iLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAweDBmKSB0aGlzLnBhY2tfdWludDgoMHhhMCArIGxlbmd0aCk7XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGEpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQxNihsZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRiKTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50MzIobGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbGVuZ3RoXCIpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZF9idWZmZXIoYmxvYik7XG4gICAgfVxuICAgIHBhY2tfc3RyaW5nKHN0cikge1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gdGhpcy5fdGV4dEVuY29kZXIuZW5jb2RlKHN0cik7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDB4MGYpIHRoaXMucGFja191aW50OCgweGIwICsgbGVuZ3RoKTtcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkOCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDE2KGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZDkpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQzMihsZW5ndGgpO1xuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsZW5ndGhcIik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kX2J1ZmZlcihlbmNvZGVkKTtcbiAgICB9XG4gICAgcGFja19hcnJheShhcnkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJ5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAweDBmKSB0aGlzLnBhY2tfdWludDgoMHg5MCArIGxlbmd0aCk7XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGMpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQxNihsZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRkKTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50MzIobGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbGVuZ3RoXCIpO1xuICAgICAgICBjb25zdCBwYWNrTmV4dCA9IChpbmRleCk9PntcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMucGFjayhhcnlbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHJlcy50aGVuKCgpPT5wYWNrTmV4dChpbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja05leHQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhY2tOZXh0KDApO1xuICAgIH1cbiAgICBwYWNrX2ludGVnZXIobnVtKSB7XG4gICAgICAgIGlmIChudW0gPj0gLTMyICYmIG51bSA8PSAweDdmKSB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gJiAweGZmKTtcbiAgICAgICAgZWxzZSBpZiAobnVtID49IDB4MDAgJiYgbnVtIDw9IDB4ZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2MpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQ4KG51bSk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtID49IC0xMjggJiYgbnVtIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZDApO1xuICAgICAgICAgICAgdGhpcy5wYWNrX2ludDgobnVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gMHgwMDAwICYmIG51bSA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2QpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQxNihudW0pO1xuICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSAtMzI3NjggJiYgbnVtIDw9IDB4N2ZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkMSk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfaW50MTYobnVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gMHgwMDAwMDAwMCAmJiBudW0gPD0gMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjZSk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDMyKG51bSk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtID49IC0yMTQ3NDgzNjQ4ICYmIG51bSA8PSAweDdmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQyKTtcbiAgICAgICAgICAgIHRoaXMucGFja19pbnQzMihudW0pO1xuICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSAtOTIyMzM3MjAzNjg1NDc3NjAwMCAmJiBudW0gPD0gMHg3ZmZmZmZmZmZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQzKTtcbiAgICAgICAgICAgIHRoaXMucGFja19pbnQ2NChudW0pO1xuICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSAweDAwMDAwMDAwMDAwMDAwMDAgJiYgbnVtIDw9IDB4ZmZmZmZmZmZmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjZik7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDY0KG51bSk7XG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXJcIik7XG4gICAgfVxuICAgIHBhY2tfZG91YmxlKG51bSkge1xuICAgICAgICBsZXQgc2lnbiA9IDA7XG4gICAgICAgIGlmIChudW0gPCAwKSB7XG4gICAgICAgICAgICBzaWduID0gMTtcbiAgICAgICAgICAgIG51bSA9IC1udW07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwID0gTWF0aC5mbG9vcihNYXRoLmxvZyhudW0pIC8gTWF0aC5MTjIpO1xuICAgICAgICBjb25zdCBmcmFjMCA9IG51bSAvIDIgKiogZXhwIC0gMTtcbiAgICAgICAgY29uc3QgZnJhYzEgPSBNYXRoLmZsb29yKGZyYWMwICogMiAqKiA1Mik7XG4gICAgICAgIGNvbnN0IGIzMiA9IDIgKiogMzI7XG4gICAgICAgIGNvbnN0IGgzMiA9IHNpZ24gPDwgMzEgfCBleHAgKyAxMDIzIDw8IDIwIHwgZnJhYzEgLyBiMzIgJiAweDBmZmZmZjtcbiAgICAgICAgY29uc3QgbDMyID0gZnJhYzEgJSBiMzI7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2IpO1xuICAgICAgICB0aGlzLnBhY2tfaW50MzIoaDMyKTtcbiAgICAgICAgdGhpcy5wYWNrX2ludDMyKGwzMik7XG4gICAgfVxuICAgIHBhY2tfb2JqZWN0KG9iaikge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPD0gMHgwZikgdGhpcy5wYWNrX3VpbnQ4KDB4ODAgKyBsZW5ndGgpO1xuICAgICAgICBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRlKTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50MTYobGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkZik7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDMyKGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxlbmd0aFwiKTtcbiAgICAgICAgY29uc3QgcGFja05leHQgPSAoaW5kZXgpPT57XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2socHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMucGFjayhvYmpbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHJlcy50aGVuKCgpPT5wYWNrTmV4dChpbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2tOZXh0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYWNrTmV4dCgwKTtcbiAgICB9XG4gICAgcGFja191aW50OChudW0pIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtKTtcbiAgICB9XG4gICAgcGFja191aW50MTYobnVtKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSA+PiA4KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtICYgMHhmZik7XG4gICAgfVxuICAgIHBhY2tfdWludDMyKG51bSkge1xuICAgICAgICBjb25zdCBuID0gbnVtICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKG4gJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobiAmIDB4MDBmZjAwMDApID4+PiAxNik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChuICYgMHgwMDAwZmYwMCkgPj4+IDgpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChuICYgMHgwMDAwMDBmZik7XG4gICAgfVxuICAgIHBhY2tfdWludDY0KG51bSkge1xuICAgICAgICBjb25zdCBoaWdoID0gbnVtIC8gMiAqKiAzMjtcbiAgICAgICAgY29uc3QgbG93ID0gbnVtICUgMiAqKiAzMjtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4MDBmZjAwMDApID4+PiAxNik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHgwMDAwZmYwMCkgPj4+IDgpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChoaWdoICYgMHgwMDAwMDBmZik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAmIDB4MDAwMGZmMDApID4+PiA4KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobG93ICYgMHgwMDAwMDBmZik7XG4gICAgfVxuICAgIHBhY2tfaW50OChudW0pIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtICYgMHhmZik7XG4gICAgfVxuICAgIHBhY2tfaW50MTYobnVtKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChudW0gJiAweGZmMDApID4+IDgpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gJiAweGZmKTtcbiAgICB9XG4gICAgcGFja19pbnQzMihudW0pIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtID4+PiAyNCAmIDB4ZmYpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKG51bSAmIDB4MDAwMGZmMDApID4+PiA4KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtICYgMHgwMDAwMDBmZik7XG4gICAgfVxuICAgIHBhY2tfaW50NjQobnVtKSB7XG4gICAgICAgIGNvbnN0IGhpZ2ggPSBNYXRoLmZsb29yKG51bSAvIDIgKiogMzIpO1xuICAgICAgICBjb25zdCBsb3cgPSBudW0gJSAyICoqIDMyO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4ZmYwMDAwMDApID4+PiAyNCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweDAwMDBmZjAwKSA+Pj4gOCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKGhpZ2ggJiAweDAwMDAwMGZmKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAmIDB4ZmYwMDAwMDApID4+PiAyNCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgJiAweDAwZmYwMDAwKSA+Pj4gMTYpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICYgMHgwMDAwZmYwMCkgPj4+IDgpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChsb3cgJiAweDAwMDAwMGZmKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlciA9IG5ldyAoMCwgJGU4Mzc5ODE4NjUwZTI0NDIkZXhwb3J0JDkzNjU0ZDRmMmQ2Y2Q1MjQpKCk7XG4gICAgICAgIHRoaXMuX3RleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCB7JDBjZmQ3ODI4YWQ1OTExNWYkZXhwb3J0JDQxNzg1NzAxMGRjOTI4N2YgYXMgdW5wYWNrLCAkMGNmZDc4MjhhZDU5MTE1ZiRleHBvcnQkMmE3MDNkYmIwY2IzNTMzOSBhcyBwYWNrLCAkMGNmZDc4MjhhZDU5MTE1ZiRleHBvcnQkYjllYzRiMTE0YWE0MDA3NCBhcyBQYWNrZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluYXJ5cGFjay5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/peerjs-js-binarypack/dist/binarypack.mjs\n");

/***/ })

};
;