"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/svgpath";
exports.ids = ["vendor-chunks/svgpath"];
exports.modules = {

/***/ "(ssr)/./node_modules/svgpath/index.js":
/*!***************************************!*\
  !*** ./node_modules/svgpath/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/svgpath */ \"(ssr)/./node_modules/svgpath/lib/svgpath.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix3R0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb3VuZGJvYXJkLy4vbm9kZV9tb2R1bGVzL3N2Z3BhdGgvaW5kZXguanM/OTljZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvc3ZncGF0aCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/svgpath/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/svgpath/lib/a2c.js":
/*!*****************************************!*\
  !*** ./node_modules/svgpath/lib/a2c.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// Convert an arc to a sequence of cubic bézier curves\n//\n\n\n\nvar TAU = Math.PI * 2;\n\n\n/* eslint-disable space-infix-ops */\n\n// Calculate an angle between two unit vectors\n//\n// Since we measure angle between radii of circular arcs,\n// we can use simplified math (without length normalization)\n//\nfunction unit_vector_angle(ux, uy, vx, vy) {\n  var sign = (ux * vy - uy * vx < 0) ? -1 : 1;\n  var dot  = ux * vx + uy * vy;\n\n  // Add this to work with arbitrary vectors:\n  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n\n  // rounding errors, e.g. -1.0000000000000002 can screw up this\n  if (dot >  1.0) { dot =  1.0; }\n  if (dot < -1.0) { dot = -1.0; }\n\n  return sign * Math.acos(dot);\n}\n\n\n// Convert from endpoint to center parameterization,\n// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n//\n// Return [cx, cy, theta1, delta_theta]\n//\nfunction get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {\n  // Step 1.\n  //\n  // Moving an ellipse so origin will be the middlepoint between our two\n  // points. After that, rotate it to line up ellipse axes with coordinate\n  // axes.\n  //\n  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;\n  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;\n\n  var rx_sq  =  rx * rx;\n  var ry_sq  =  ry * ry;\n  var x1p_sq = x1p * x1p;\n  var y1p_sq = y1p * y1p;\n\n  // Step 2.\n  //\n  // Compute coordinates of the centre of this ellipse (cx', cy')\n  // in the new coordinate system.\n  //\n  var radicant = (rx_sq * ry_sq) - (rx_sq * y1p_sq) - (ry_sq * x1p_sq);\n\n  if (radicant < 0) {\n    // due to rounding errors it might be e.g. -1.3877787807814457e-17\n    radicant = 0;\n  }\n\n  radicant /=   (rx_sq * y1p_sq) + (ry_sq * x1p_sq);\n  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);\n\n  var cxp = radicant *  rx/ry * y1p;\n  var cyp = radicant * -ry/rx * x1p;\n\n  // Step 3.\n  //\n  // Transform back to get centre coordinates (cx, cy) in the original\n  // coordinate system.\n  //\n  var cx = cos_phi*cxp - sin_phi*cyp + (x1+x2)/2;\n  var cy = sin_phi*cxp + cos_phi*cyp + (y1+y2)/2;\n\n  // Step 4.\n  //\n  // Compute angles (theta1, delta_theta).\n  //\n  var v1x =  (x1p - cxp) / rx;\n  var v1y =  (y1p - cyp) / ry;\n  var v2x = (-x1p - cxp) / rx;\n  var v2y = (-y1p - cyp) / ry;\n\n  var theta1 = unit_vector_angle(1, 0, v1x, v1y);\n  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);\n\n  if (fs === 0 && delta_theta > 0) {\n    delta_theta -= TAU;\n  }\n  if (fs === 1 && delta_theta < 0) {\n    delta_theta += TAU;\n  }\n\n  return [ cx, cy, theta1, delta_theta ];\n}\n\n//\n// Approximate one unit arc segment with bézier curves,\n// see http://math.stackexchange.com/questions/873224\n//\nfunction approximate_unit_arc(theta1, delta_theta) {\n  var alpha = 4/3 * Math.tan(delta_theta/4);\n\n  var x1 = Math.cos(theta1);\n  var y1 = Math.sin(theta1);\n  var x2 = Math.cos(theta1 + delta_theta);\n  var y2 = Math.sin(theta1 + delta_theta);\n\n  return [ x1, y1, x1 - y1*alpha, y1 + x1*alpha, x2 + y2*alpha, y2 - x2*alpha, x2, y2 ];\n}\n\nmodule.exports = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {\n  var sin_phi = Math.sin(phi * TAU / 360);\n  var cos_phi = Math.cos(phi * TAU / 360);\n\n  // Make sure radii are valid\n  //\n  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;\n  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;\n\n  if (x1p === 0 && y1p === 0) {\n    // we're asked to draw line to itself\n    return [];\n  }\n\n  if (rx === 0 || ry === 0) {\n    // one of the radii is zero\n    return [];\n  }\n\n\n  // Compensate out-of-range radii\n  //\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n\n  // Get center parameters (cx, cy, theta1, delta_theta)\n  //\n  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);\n\n  var result = [];\n  var theta1 = cc[2];\n  var delta_theta = cc[3];\n\n  // Split an arc to multiple segments, so each segment\n  // will be less than τ/4 (= 90°)\n  //\n  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);\n  delta_theta /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    result.push(approximate_unit_arc(theta1, delta_theta));\n    theta1 += delta_theta;\n  }\n\n  // We have a bezier approximation of a unit circle,\n  // now need to transform back to the original ellipse\n  //\n  return result.map(function (curve) {\n    for (var i = 0; i < curve.length; i += 2) {\n      var x = curve[i + 0];\n      var y = curve[i + 1];\n\n      // scale\n      x *= rx;\n      y *= ry;\n\n      // rotate\n      var xp = cos_phi*x - sin_phi*y;\n      var yp = sin_phi*x + cos_phi*y;\n\n      // translate\n      curve[i + 0] = xp + cc[0];\n      curve[i + 1] = yp + cc[1];\n    }\n\n    return curve;\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvYTJjLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDYTs7O0FBR2I7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb3VuZGJvYXJkLy4vbm9kZV9tb2R1bGVzL3N2Z3BhdGgvbGliL2EyYy5qcz8zZGFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbnZlcnQgYW4gYXJjIHRvIGEgc2VxdWVuY2Ugb2YgY3ViaWMgYsOpemllciBjdXJ2ZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFRBVSA9IE1hdGguUEkgKiAyO1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLWluZml4LW9wcyAqL1xuXG4vLyBDYWxjdWxhdGUgYW4gYW5nbGUgYmV0d2VlbiB0d28gdW5pdCB2ZWN0b3JzXG4vL1xuLy8gU2luY2Ugd2UgbWVhc3VyZSBhbmdsZSBiZXR3ZWVuIHJhZGlpIG9mIGNpcmN1bGFyIGFyY3MsXG4vLyB3ZSBjYW4gdXNlIHNpbXBsaWZpZWQgbWF0aCAod2l0aG91dCBsZW5ndGggbm9ybWFsaXphdGlvbilcbi8vXG5mdW5jdGlvbiB1bml0X3ZlY3Rvcl9hbmdsZSh1eCwgdXksIHZ4LCB2eSkge1xuICB2YXIgc2lnbiA9ICh1eCAqIHZ5IC0gdXkgKiB2eCA8IDApID8gLTEgOiAxO1xuICB2YXIgZG90ICA9IHV4ICogdnggKyB1eSAqIHZ5O1xuXG4gIC8vIEFkZCB0aGlzIHRvIHdvcmsgd2l0aCBhcmJpdHJhcnkgdmVjdG9yczpcbiAgLy8gZG90IC89IE1hdGguc3FydCh1eCAqIHV4ICsgdXkgKiB1eSkgKiBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuXG4gIC8vIHJvdW5kaW5nIGVycm9ycywgZS5nLiAtMS4wMDAwMDAwMDAwMDAwMDAyIGNhbiBzY3JldyB1cCB0aGlzXG4gIGlmIChkb3QgPiAgMS4wKSB7IGRvdCA9ICAxLjA7IH1cbiAgaWYgKGRvdCA8IC0xLjApIHsgZG90ID0gLTEuMDsgfVxuXG4gIHJldHVybiBzaWduICogTWF0aC5hY29zKGRvdCk7XG59XG5cblxuLy8gQ29udmVydCBmcm9tIGVuZHBvaW50IHRvIGNlbnRlciBwYXJhbWV0ZXJpemF0aW9uLFxuLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuLy9cbi8vIFJldHVybiBbY3gsIGN5LCB0aGV0YTEsIGRlbHRhX3RoZXRhXVxuLy9cbmZ1bmN0aW9uIGdldF9hcmNfY2VudGVyKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgc2luX3BoaSwgY29zX3BoaSkge1xuICAvLyBTdGVwIDEuXG4gIC8vXG4gIC8vIE1vdmluZyBhbiBlbGxpcHNlIHNvIG9yaWdpbiB3aWxsIGJlIHRoZSBtaWRkbGVwb2ludCBiZXR3ZWVuIG91ciB0d29cbiAgLy8gcG9pbnRzLiBBZnRlciB0aGF0LCByb3RhdGUgaXQgdG8gbGluZSB1cCBlbGxpcHNlIGF4ZXMgd2l0aCBjb29yZGluYXRlXG4gIC8vIGF4ZXMuXG4gIC8vXG4gIHZhciB4MXAgPSAgY29zX3BoaSooeDEteDIpLzIgKyBzaW5fcGhpKih5MS15MikvMjtcbiAgdmFyIHkxcCA9IC1zaW5fcGhpKih4MS14MikvMiArIGNvc19waGkqKHkxLXkyKS8yO1xuXG4gIHZhciByeF9zcSAgPSAgcnggKiByeDtcbiAgdmFyIHJ5X3NxICA9ICByeSAqIHJ5O1xuICB2YXIgeDFwX3NxID0geDFwICogeDFwO1xuICB2YXIgeTFwX3NxID0geTFwICogeTFwO1xuXG4gIC8vIFN0ZXAgMi5cbiAgLy9cbiAgLy8gQ29tcHV0ZSBjb29yZGluYXRlcyBvZiB0aGUgY2VudHJlIG9mIHRoaXMgZWxsaXBzZSAoY3gnLCBjeScpXG4gIC8vIGluIHRoZSBuZXcgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gIC8vXG4gIHZhciByYWRpY2FudCA9IChyeF9zcSAqIHJ5X3NxKSAtIChyeF9zcSAqIHkxcF9zcSkgLSAocnlfc3EgKiB4MXBfc3EpO1xuXG4gIGlmIChyYWRpY2FudCA8IDApIHtcbiAgICAvLyBkdWUgdG8gcm91bmRpbmcgZXJyb3JzIGl0IG1pZ2h0IGJlIGUuZy4gLTEuMzg3Nzc4NzgwNzgxNDQ1N2UtMTdcbiAgICByYWRpY2FudCA9IDA7XG4gIH1cblxuICByYWRpY2FudCAvPSAgIChyeF9zcSAqIHkxcF9zcSkgKyAocnlfc3EgKiB4MXBfc3EpO1xuICByYWRpY2FudCA9IE1hdGguc3FydChyYWRpY2FudCkgKiAoZmEgPT09IGZzID8gLTEgOiAxKTtcblxuICB2YXIgY3hwID0gcmFkaWNhbnQgKiAgcngvcnkgKiB5MXA7XG4gIHZhciBjeXAgPSByYWRpY2FudCAqIC1yeS9yeCAqIHgxcDtcblxuICAvLyBTdGVwIDMuXG4gIC8vXG4gIC8vIFRyYW5zZm9ybSBiYWNrIHRvIGdldCBjZW50cmUgY29vcmRpbmF0ZXMgKGN4LCBjeSkgaW4gdGhlIG9yaWdpbmFsXG4gIC8vIGNvb3JkaW5hdGUgc3lzdGVtLlxuICAvL1xuICB2YXIgY3ggPSBjb3NfcGhpKmN4cCAtIHNpbl9waGkqY3lwICsgKHgxK3gyKS8yO1xuICB2YXIgY3kgPSBzaW5fcGhpKmN4cCArIGNvc19waGkqY3lwICsgKHkxK3kyKS8yO1xuXG4gIC8vIFN0ZXAgNC5cbiAgLy9cbiAgLy8gQ29tcHV0ZSBhbmdsZXMgKHRoZXRhMSwgZGVsdGFfdGhldGEpLlxuICAvL1xuICB2YXIgdjF4ID0gICh4MXAgLSBjeHApIC8gcng7XG4gIHZhciB2MXkgPSAgKHkxcCAtIGN5cCkgLyByeTtcbiAgdmFyIHYyeCA9ICgteDFwIC0gY3hwKSAvIHJ4O1xuICB2YXIgdjJ5ID0gKC15MXAgLSBjeXApIC8gcnk7XG5cbiAgdmFyIHRoZXRhMSA9IHVuaXRfdmVjdG9yX2FuZ2xlKDEsIDAsIHYxeCwgdjF5KTtcbiAgdmFyIGRlbHRhX3RoZXRhID0gdW5pdF92ZWN0b3JfYW5nbGUodjF4LCB2MXksIHYyeCwgdjJ5KTtcblxuICBpZiAoZnMgPT09IDAgJiYgZGVsdGFfdGhldGEgPiAwKSB7XG4gICAgZGVsdGFfdGhldGEgLT0gVEFVO1xuICB9XG4gIGlmIChmcyA9PT0gMSAmJiBkZWx0YV90aGV0YSA8IDApIHtcbiAgICBkZWx0YV90aGV0YSArPSBUQVU7XG4gIH1cblxuICByZXR1cm4gWyBjeCwgY3ksIHRoZXRhMSwgZGVsdGFfdGhldGEgXTtcbn1cblxuLy9cbi8vIEFwcHJveGltYXRlIG9uZSB1bml0IGFyYyBzZWdtZW50IHdpdGggYsOpemllciBjdXJ2ZXMsXG4vLyBzZWUgaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzg3MzIyNFxuLy9cbmZ1bmN0aW9uIGFwcHJveGltYXRlX3VuaXRfYXJjKHRoZXRhMSwgZGVsdGFfdGhldGEpIHtcbiAgdmFyIGFscGhhID0gNC8zICogTWF0aC50YW4oZGVsdGFfdGhldGEvNCk7XG5cbiAgdmFyIHgxID0gTWF0aC5jb3ModGhldGExKTtcbiAgdmFyIHkxID0gTWF0aC5zaW4odGhldGExKTtcbiAgdmFyIHgyID0gTWF0aC5jb3ModGhldGExICsgZGVsdGFfdGhldGEpO1xuICB2YXIgeTIgPSBNYXRoLnNpbih0aGV0YTEgKyBkZWx0YV90aGV0YSk7XG5cbiAgcmV0dXJuIFsgeDEsIHkxLCB4MSAtIHkxKmFscGhhLCB5MSArIHgxKmFscGhhLCB4MiArIHkyKmFscGhhLCB5MiAtIHgyKmFscGhhLCB4MiwgeTIgXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhMmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwaGkpIHtcbiAgdmFyIHNpbl9waGkgPSBNYXRoLnNpbihwaGkgKiBUQVUgLyAzNjApO1xuICB2YXIgY29zX3BoaSA9IE1hdGguY29zKHBoaSAqIFRBVSAvIDM2MCk7XG5cbiAgLy8gTWFrZSBzdXJlIHJhZGlpIGFyZSB2YWxpZFxuICAvL1xuICB2YXIgeDFwID0gIGNvc19waGkqKHgxLXgyKS8yICsgc2luX3BoaSooeTEteTIpLzI7XG4gIHZhciB5MXAgPSAtc2luX3BoaSooeDEteDIpLzIgKyBjb3NfcGhpKih5MS15MikvMjtcblxuICBpZiAoeDFwID09PSAwICYmIHkxcCA9PT0gMCkge1xuICAgIC8vIHdlJ3JlIGFza2VkIHRvIGRyYXcgbGluZSB0byBpdHNlbGZcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAocnggPT09IDAgfHwgcnkgPT09IDApIHtcbiAgICAvLyBvbmUgb2YgdGhlIHJhZGlpIGlzIHplcm9cbiAgICByZXR1cm4gW107XG4gIH1cblxuXG4gIC8vIENvbXBlbnNhdGUgb3V0LW9mLXJhbmdlIHJhZGlpXG4gIC8vXG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcblxuICB2YXIgbGFtYmRhID0gKHgxcCAqIHgxcCkgLyAocnggKiByeCkgKyAoeTFwICogeTFwKSAvIChyeSAqIHJ5KTtcbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgICByeSAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgfVxuXG5cbiAgLy8gR2V0IGNlbnRlciBwYXJhbWV0ZXJzIChjeCwgY3ksIHRoZXRhMSwgZGVsdGFfdGhldGEpXG4gIC8vXG4gIHZhciBjYyA9IGdldF9hcmNfY2VudGVyKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgc2luX3BoaSwgY29zX3BoaSk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdGhldGExID0gY2NbMl07XG4gIHZhciBkZWx0YV90aGV0YSA9IGNjWzNdO1xuXG4gIC8vIFNwbGl0IGFuIGFyYyB0byBtdWx0aXBsZSBzZWdtZW50cywgc28gZWFjaCBzZWdtZW50XG4gIC8vIHdpbGwgYmUgbGVzcyB0aGFuIM+ELzQgKD0gOTDCsClcbiAgLy9cbiAgdmFyIHNlZ21lbnRzID0gTWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKGRlbHRhX3RoZXRhKSAvIChUQVUgLyA0KSksIDEpO1xuICBkZWx0YV90aGV0YSAvPSBzZWdtZW50cztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChhcHByb3hpbWF0ZV91bml0X2FyYyh0aGV0YTEsIGRlbHRhX3RoZXRhKSk7XG4gICAgdGhldGExICs9IGRlbHRhX3RoZXRhO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBhIGJlemllciBhcHByb3hpbWF0aW9uIG9mIGEgdW5pdCBjaXJjbGUsXG4gIC8vIG5vdyBuZWVkIHRvIHRyYW5zZm9ybSBiYWNrIHRvIHRoZSBvcmlnaW5hbCBlbGxpcHNlXG4gIC8vXG4gIHJldHVybiByZXN1bHQubWFwKGZ1bmN0aW9uIChjdXJ2ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciB4ID0gY3VydmVbaSArIDBdO1xuICAgICAgdmFyIHkgPSBjdXJ2ZVtpICsgMV07XG5cbiAgICAgIC8vIHNjYWxlXG4gICAgICB4ICo9IHJ4O1xuICAgICAgeSAqPSByeTtcblxuICAgICAgLy8gcm90YXRlXG4gICAgICB2YXIgeHAgPSBjb3NfcGhpKnggLSBzaW5fcGhpKnk7XG4gICAgICB2YXIgeXAgPSBzaW5fcGhpKnggKyBjb3NfcGhpKnk7XG5cbiAgICAgIC8vIHRyYW5zbGF0ZVxuICAgICAgY3VydmVbaSArIDBdID0geHAgKyBjY1swXTtcbiAgICAgIGN1cnZlW2kgKyAxXSA9IHlwICsgY2NbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnZlO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/svgpath/lib/a2c.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/svgpath/lib/ellipse.js":
/*!*********************************************!*\
  !*** ./node_modules/svgpath/lib/ellipse.js ***!
  \*********************************************/
/***/ ((module) => {

eval("\n\n/* eslint-disable space-infix-ops */\n\n// The precision used to consider an ellipse as a circle\n//\nvar epsilon = 0.0000000001;\n\n// To convert degree in radians\n//\nvar torad = Math.PI / 180;\n\n// Class constructor :\n//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.\n//\nfunction Ellipse(rx, ry, ax) {\n  if (!(this instanceof Ellipse)) { return new Ellipse(rx, ry, ax); }\n  this.rx = rx;\n  this.ry = ry;\n  this.ax = ax;\n}\n\n// Apply a linear transform m to the ellipse\n// m is an array representing a matrix :\n//    -         -\n//   | m[0] m[2] |\n//   | m[1] m[3] |\n//    -         -\n//\nEllipse.prototype.transform = function (m) {\n  // We consider the current ellipse as image of the unit circle\n  // by first scale(rx,ry) and then rotate(ax) ...\n  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.\n  var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);\n  var ma = [\n    this.rx * (m[0]*c + m[2]*s),\n    this.rx * (m[1]*c + m[3]*s),\n    this.ry * (-m[0]*s + m[2]*c),\n    this.ry * (-m[1]*s + m[3]*c)\n  ];\n\n  // ma * transpose(ma) = [ J L ]\n  //                      [ L K ]\n  // L is calculated later (if the image is not a circle)\n  var J = ma[0]*ma[0] + ma[2]*ma[2],\n      K = ma[1]*ma[1] + ma[3]*ma[3];\n\n  // the discriminant of the characteristic polynomial of ma * transpose(ma)\n  var D = ((ma[0]-ma[3])*(ma[0]-ma[3]) + (ma[2]+ma[1])*(ma[2]+ma[1])) *\n          ((ma[0]+ma[3])*(ma[0]+ma[3]) + (ma[2]-ma[1])*(ma[2]-ma[1]));\n\n  // the \"mean eigenvalue\"\n  var JK = (J + K) / 2;\n\n  // check if the image is (almost) a circle\n  if (D < epsilon * JK) {\n    // if it is\n    this.rx = this.ry = Math.sqrt(JK);\n    this.ax = 0;\n    return this;\n  }\n\n  // if it is not a circle\n  var L = ma[0]*ma[1] + ma[2]*ma[3];\n\n  D = Math.sqrt(D);\n\n  // {l1,l2} = the two eigen values of ma * transpose(ma)\n  var l1 = JK + D/2,\n      l2 = JK - D/2;\n  // the x - axis - rotation angle is the argument of the l1 - eigenvector\n  /*eslint-disable indent*/\n  this.ax = (Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon) ?\n    90\n  :\n    Math.atan(Math.abs(L) > Math.abs(l1 - K) ?\n      (l1 - J) / L\n    :\n      L / (l1 - K)\n    ) * 180 / Math.PI;\n  /*eslint-enable indent*/\n\n  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90\n  if (this.ax >= 0) {\n    // if ax in [0,90]\n    this.rx = Math.sqrt(l1);\n    this.ry = Math.sqrt(l2);\n  } else {\n    // if ax in ]-90,0[ => exchange axes\n    this.ax += 90;\n    this.rx = Math.sqrt(l2);\n    this.ry = Math.sqrt(l1);\n  }\n\n  return this;\n};\n\n// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0\n//\nEllipse.prototype.isDegenerate = function () {\n  return (this.rx < epsilon * this.ry || this.ry < epsilon * this.rx);\n};\n\nmodule.exports = Ellipse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvZWxsaXBzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NvdW5kYm9hcmQvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvZWxsaXBzZS5qcz9lMGI4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtaW5maXgtb3BzICovXG5cbi8vIFRoZSBwcmVjaXNpb24gdXNlZCB0byBjb25zaWRlciBhbiBlbGxpcHNlIGFzIGEgY2lyY2xlXG4vL1xudmFyIGVwc2lsb24gPSAwLjAwMDAwMDAwMDE7XG5cbi8vIFRvIGNvbnZlcnQgZGVncmVlIGluIHJhZGlhbnNcbi8vXG52YXIgdG9yYWQgPSBNYXRoLlBJIC8gMTgwO1xuXG4vLyBDbGFzcyBjb25zdHJ1Y3RvciA6XG4vLyAgYW4gZWxsaXBzZSBjZW50cmVkIGF0IDAgd2l0aCByYWRpaSByeCxyeSBhbmQgeCAtIGF4aXMgLSBhbmdsZSBheC5cbi8vXG5mdW5jdGlvbiBFbGxpcHNlKHJ4LCByeSwgYXgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVsbGlwc2UpKSB7IHJldHVybiBuZXcgRWxsaXBzZShyeCwgcnksIGF4KTsgfVxuICB0aGlzLnJ4ID0gcng7XG4gIHRoaXMucnkgPSByeTtcbiAgdGhpcy5heCA9IGF4O1xufVxuXG4vLyBBcHBseSBhIGxpbmVhciB0cmFuc2Zvcm0gbSB0byB0aGUgZWxsaXBzZVxuLy8gbSBpcyBhbiBhcnJheSByZXByZXNlbnRpbmcgYSBtYXRyaXggOlxuLy8gICAgLSAgICAgICAgIC1cbi8vICAgfCBtWzBdIG1bMl0gfFxuLy8gICB8IG1bMV0gbVszXSB8XG4vLyAgICAtICAgICAgICAgLVxuLy9cbkVsbGlwc2UucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gIC8vIFdlIGNvbnNpZGVyIHRoZSBjdXJyZW50IGVsbGlwc2UgYXMgaW1hZ2Ugb2YgdGhlIHVuaXQgY2lyY2xlXG4gIC8vIGJ5IGZpcnN0IHNjYWxlKHJ4LHJ5KSBhbmQgdGhlbiByb3RhdGUoYXgpIC4uLlxuICAvLyBTbyB3ZSBhcHBseSBtYSA9ICBtIHggcm90YXRlKGF4KSB4IHNjYWxlKHJ4LHJ5KSB0byB0aGUgdW5pdCBjaXJjbGUuXG4gIHZhciBjID0gTWF0aC5jb3ModGhpcy5heCAqIHRvcmFkKSwgcyA9IE1hdGguc2luKHRoaXMuYXggKiB0b3JhZCk7XG4gIHZhciBtYSA9IFtcbiAgICB0aGlzLnJ4ICogKG1bMF0qYyArIG1bMl0qcyksXG4gICAgdGhpcy5yeCAqIChtWzFdKmMgKyBtWzNdKnMpLFxuICAgIHRoaXMucnkgKiAoLW1bMF0qcyArIG1bMl0qYyksXG4gICAgdGhpcy5yeSAqICgtbVsxXSpzICsgbVszXSpjKVxuICBdO1xuXG4gIC8vIG1hICogdHJhbnNwb3NlKG1hKSA9IFsgSiBMIF1cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgWyBMIEsgXVxuICAvLyBMIGlzIGNhbGN1bGF0ZWQgbGF0ZXIgKGlmIHRoZSBpbWFnZSBpcyBub3QgYSBjaXJjbGUpXG4gIHZhciBKID0gbWFbMF0qbWFbMF0gKyBtYVsyXSptYVsyXSxcbiAgICAgIEsgPSBtYVsxXSptYVsxXSArIG1hWzNdKm1hWzNdO1xuXG4gIC8vIHRoZSBkaXNjcmltaW5hbnQgb2YgdGhlIGNoYXJhY3RlcmlzdGljIHBvbHlub21pYWwgb2YgbWEgKiB0cmFuc3Bvc2UobWEpXG4gIHZhciBEID0gKChtYVswXS1tYVszXSkqKG1hWzBdLW1hWzNdKSArIChtYVsyXSttYVsxXSkqKG1hWzJdK21hWzFdKSkgKlxuICAgICAgICAgICgobWFbMF0rbWFbM10pKihtYVswXSttYVszXSkgKyAobWFbMl0tbWFbMV0pKihtYVsyXS1tYVsxXSkpO1xuXG4gIC8vIHRoZSBcIm1lYW4gZWlnZW52YWx1ZVwiXG4gIHZhciBKSyA9IChKICsgSykgLyAyO1xuXG4gIC8vIGNoZWNrIGlmIHRoZSBpbWFnZSBpcyAoYWxtb3N0KSBhIGNpcmNsZVxuICBpZiAoRCA8IGVwc2lsb24gKiBKSykge1xuICAgIC8vIGlmIGl0IGlzXG4gICAgdGhpcy5yeCA9IHRoaXMucnkgPSBNYXRoLnNxcnQoSkspO1xuICAgIHRoaXMuYXggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gaWYgaXQgaXMgbm90IGEgY2lyY2xlXG4gIHZhciBMID0gbWFbMF0qbWFbMV0gKyBtYVsyXSptYVszXTtcblxuICBEID0gTWF0aC5zcXJ0KEQpO1xuXG4gIC8vIHtsMSxsMn0gPSB0aGUgdHdvIGVpZ2VuIHZhbHVlcyBvZiBtYSAqIHRyYW5zcG9zZShtYSlcbiAgdmFyIGwxID0gSksgKyBELzIsXG4gICAgICBsMiA9IEpLIC0gRC8yO1xuICAvLyB0aGUgeCAtIGF4aXMgLSByb3RhdGlvbiBhbmdsZSBpcyB0aGUgYXJndW1lbnQgb2YgdGhlIGwxIC0gZWlnZW52ZWN0b3JcbiAgLyplc2xpbnQtZGlzYWJsZSBpbmRlbnQqL1xuICB0aGlzLmF4ID0gKE1hdGguYWJzKEwpIDwgZXBzaWxvbiAmJiBNYXRoLmFicyhsMSAtIEspIDwgZXBzaWxvbikgP1xuICAgIDkwXG4gIDpcbiAgICBNYXRoLmF0YW4oTWF0aC5hYnMoTCkgPiBNYXRoLmFicyhsMSAtIEspID9cbiAgICAgIChsMSAtIEopIC8gTFxuICAgIDpcbiAgICAgIEwgLyAobDEgLSBLKVxuICAgICkgKiAxODAgLyBNYXRoLlBJO1xuICAvKmVzbGludC1lbmFibGUgaW5kZW50Ki9cblxuICAvLyBpZiBheCA+IDAgPT4gcnggPSBzcXJ0KGwxKSwgcnkgPSBzcXJ0KGwyKSwgZWxzZSBleGNoYW5nZSBheGVzIGFuZCBheCArPSA5MFxuICBpZiAodGhpcy5heCA+PSAwKSB7XG4gICAgLy8gaWYgYXggaW4gWzAsOTBdXG4gICAgdGhpcy5yeCA9IE1hdGguc3FydChsMSk7XG4gICAgdGhpcy5yeSA9IE1hdGguc3FydChsMik7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgYXggaW4gXS05MCwwWyA9PiBleGNoYW5nZSBheGVzXG4gICAgdGhpcy5heCArPSA5MDtcbiAgICB0aGlzLnJ4ID0gTWF0aC5zcXJ0KGwyKTtcbiAgICB0aGlzLnJ5ID0gTWF0aC5zcXJ0KGwxKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gQ2hlY2sgaWYgdGhlIGVsbGlwc2UgaXMgKGFsbW9zdCkgZGVnZW5lcmF0ZSwgaS5lLiByeCA9IDAgb3IgcnkgPSAwXG4vL1xuRWxsaXBzZS5wcm90b3R5cGUuaXNEZWdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMucnggPCBlcHNpbG9uICogdGhpcy5yeSB8fCB0aGlzLnJ5IDwgZXBzaWxvbiAqIHRoaXMucngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbGxpcHNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/svgpath/lib/ellipse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/svgpath/lib/matrix.js":
/*!********************************************!*\
  !*** ./node_modules/svgpath/lib/matrix.js ***!
  \********************************************/
/***/ ((module) => {

eval("\n\n// combine 2 matrixes\n// m1, m2 - [a, b, c, d, e, g]\n//\nfunction combine(m1, m2) {\n  return [\n    m1[0] * m2[0] + m1[2] * m2[1],\n    m1[1] * m2[0] + m1[3] * m2[1],\n    m1[0] * m2[2] + m1[2] * m2[3],\n    m1[1] * m2[2] + m1[3] * m2[3],\n    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n  ];\n}\n\n\nfunction Matrix() {\n  if (!(this instanceof Matrix)) { return new Matrix(); }\n  this.queue = [];   // list of matrixes to apply\n  this.cache = null; // combined matrix cache\n}\n\n\nMatrix.prototype.matrix = function (m) {\n  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {\n    return this;\n  }\n  this.cache = null;\n  this.queue.push(m);\n  return this;\n};\n\n\nMatrix.prototype.translate = function (tx, ty) {\n  if (tx !== 0 || ty !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, 0, 0, 1, tx, ty ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.scale = function (sx, sy) {\n  if (sx !== 1 || sy !== 1) {\n    this.cache = null;\n    this.queue.push([ sx, 0, 0, sy, 0, 0 ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.rotate = function (angle, rx, ry) {\n  var rad, cos, sin;\n\n  if (angle !== 0) {\n    this.translate(rx, ry);\n\n    rad = angle * Math.PI / 180;\n    cos = Math.cos(rad);\n    sin = Math.sin(rad);\n\n    this.queue.push([ cos, sin, -sin, cos, 0, 0 ]);\n    this.cache = null;\n\n    this.translate(-rx, -ry);\n  }\n  return this;\n};\n\n\nMatrix.prototype.skewX = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0 ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.skewY = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0 ]);\n  }\n  return this;\n};\n\n\n// Flatten queue\n//\nMatrix.prototype.toArray = function () {\n  if (this.cache) {\n    return this.cache;\n  }\n\n  if (!this.queue.length) {\n    this.cache = [ 1, 0, 0, 1, 0, 0 ];\n    return this.cache;\n  }\n\n  this.cache = this.queue[0];\n\n  if (this.queue.length === 1) {\n    return this.cache;\n  }\n\n  for (var i = 1; i < this.queue.length; i++) {\n    this.cache = combine(this.cache, this.queue[i]);\n  }\n\n  return this.cache;\n};\n\n\n// Apply list of matrixes to (x,y) point.\n// If `isRelative` set, `translate` component of matrix will be skipped\n//\nMatrix.prototype.calc = function (x, y, isRelative) {\n  var m;\n\n  // Don't change point on empty transforms queue\n  if (!this.queue.length) { return [ x, y ]; }\n\n  // Calculate final matrix, if not exists\n  //\n  // NB. if you deside to apply transforms to point one-by-one,\n  // they should be taken in reverse order\n\n  if (!this.cache) {\n    this.cache = this.toArray();\n  }\n\n  m = this.cache;\n\n  // Apply matrix to point\n  return [\n    x * m[0] + y * m[2] + (isRelative ? 0 : m[4]),\n    x * m[1] + y * m[3] + (isRelative ? 0 : m[5])\n  ];\n};\n\n\nmodule.exports = Matrix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvbWF0cml4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG1DQUFtQztBQUNuQyxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NvdW5kYm9hcmQvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvbWF0cml4LmpzPzY2ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBjb21iaW5lIDIgbWF0cml4ZXNcbi8vIG0xLCBtMiAtIFthLCBiLCBjLCBkLCBlLCBnXVxuLy9cbmZ1bmN0aW9uIGNvbWJpbmUobTEsIG0yKSB7XG4gIHJldHVybiBbXG4gICAgbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sXG4gICAgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sXG4gICAgbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM10sXG4gICAgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sXG4gICAgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSxcbiAgICBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdXG4gIF07XG59XG5cblxuZnVuY3Rpb24gTWF0cml4KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWF0cml4KSkgeyByZXR1cm4gbmV3IE1hdHJpeCgpOyB9XG4gIHRoaXMucXVldWUgPSBbXTsgICAvLyBsaXN0IG9mIG1hdHJpeGVzIHRvIGFwcGx5XG4gIHRoaXMuY2FjaGUgPSBudWxsOyAvLyBjb21iaW5lZCBtYXRyaXggY2FjaGVcbn1cblxuXG5NYXRyaXgucHJvdG90eXBlLm1hdHJpeCA9IGZ1bmN0aW9uIChtKSB7XG4gIGlmIChtWzBdID09PSAxICYmIG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCAmJiBtWzNdID09PSAxICYmIG1bNF0gPT09IDAgJiYgbVs1XSA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuY2FjaGUgPSBudWxsO1xuICB0aGlzLnF1ZXVlLnB1c2gobSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5NYXRyaXgucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh0eCwgdHkpIHtcbiAgaWYgKHR4ICE9PSAwIHx8IHR5ICE9PSAwKSB7XG4gICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKFsgMSwgMCwgMCwgMSwgdHgsIHR5IF0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5NYXRyaXgucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHN4LCBzeSkge1xuICBpZiAoc3ggIT09IDEgfHwgc3kgIT09IDEpIHtcbiAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlLnB1c2goWyBzeCwgMCwgMCwgc3ksIDAsIDAgXSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbk1hdHJpeC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlLCByeCwgcnkpIHtcbiAgdmFyIHJhZCwgY29zLCBzaW47XG5cbiAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgdGhpcy50cmFuc2xhdGUocngsIHJ5KTtcblxuICAgIHJhZCA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICBjb3MgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHNpbiA9IE1hdGguc2luKHJhZCk7XG5cbiAgICB0aGlzLnF1ZXVlLnB1c2goWyBjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwIF0pO1xuICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuXG4gICAgdGhpcy50cmFuc2xhdGUoLXJ4LCAtcnkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5NYXRyaXgucHJvdG90eXBlLnNrZXdYID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSAhPT0gMCkge1xuICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuICAgIHRoaXMucXVldWUucHVzaChbIDEsIDAsIE1hdGgudGFuKGFuZ2xlICogTWF0aC5QSSAvIDE4MCksIDEsIDAsIDAgXSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbk1hdHJpeC5wcm90b3R5cGUuc2tld1kgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgdGhpcy5jYWNoZSA9IG51bGw7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKFsgMSwgTWF0aC50YW4oYW5nbGUgKiBNYXRoLlBJIC8gMTgwKSwgMCwgMSwgMCwgMCBdKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gRmxhdHRlbiBxdWV1ZVxuLy9cbk1hdHJpeC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgfVxuXG4gIGlmICghdGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICB0aGlzLmNhY2hlID0gWyAxLCAwLCAwLCAxLCAwLCAwIF07XG4gICAgcmV0dXJuIHRoaXMuY2FjaGU7XG4gIH1cblxuICB0aGlzLmNhY2hlID0gdGhpcy5xdWV1ZVswXTtcblxuICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuY2FjaGUgPSBjb21iaW5lKHRoaXMuY2FjaGUsIHRoaXMucXVldWVbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY2FjaGU7XG59O1xuXG5cbi8vIEFwcGx5IGxpc3Qgb2YgbWF0cml4ZXMgdG8gKHgseSkgcG9pbnQuXG4vLyBJZiBgaXNSZWxhdGl2ZWAgc2V0LCBgdHJhbnNsYXRlYCBjb21wb25lbnQgb2YgbWF0cml4IHdpbGwgYmUgc2tpcHBlZFxuLy9cbk1hdHJpeC5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uICh4LCB5LCBpc1JlbGF0aXZlKSB7XG4gIHZhciBtO1xuXG4gIC8vIERvbid0IGNoYW5nZSBwb2ludCBvbiBlbXB0eSB0cmFuc2Zvcm1zIHF1ZXVlXG4gIGlmICghdGhpcy5xdWV1ZS5sZW5ndGgpIHsgcmV0dXJuIFsgeCwgeSBdOyB9XG5cbiAgLy8gQ2FsY3VsYXRlIGZpbmFsIG1hdHJpeCwgaWYgbm90IGV4aXN0c1xuICAvL1xuICAvLyBOQi4gaWYgeW91IGRlc2lkZSB0byBhcHBseSB0cmFuc2Zvcm1zIHRvIHBvaW50IG9uZS1ieS1vbmUsXG4gIC8vIHRoZXkgc2hvdWxkIGJlIHRha2VuIGluIHJldmVyc2Ugb3JkZXJcblxuICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICB0aGlzLmNhY2hlID0gdGhpcy50b0FycmF5KCk7XG4gIH1cblxuICBtID0gdGhpcy5jYWNoZTtcblxuICAvLyBBcHBseSBtYXRyaXggdG8gcG9pbnRcbiAgcmV0dXJuIFtcbiAgICB4ICogbVswXSArIHkgKiBtWzJdICsgKGlzUmVsYXRpdmUgPyAwIDogbVs0XSksXG4gICAgeCAqIG1bMV0gKyB5ICogbVszXSArIChpc1JlbGF0aXZlID8gMCA6IG1bNV0pXG4gIF07XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/svgpath/lib/matrix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/svgpath/lib/path_parse.js":
/*!************************************************!*\
  !*** ./node_modules/svgpath/lib/path_parse.js ***!
  \************************************************/
/***/ ((module) => {

eval("\n\n\nvar paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };\n\nvar SPECIAL_SPACES = [\n  0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,\n  0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF\n];\n\nfunction isSpace(ch) {\n  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) || // Line terminators\n    // White spaces\n    (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n    (ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0);\n}\n\nfunction isCommand(code) {\n  /*eslint-disable no-bitwise*/\n  switch (code | 0x20) {\n    case 0x6D/* m */:\n    case 0x7A/* z */:\n    case 0x6C/* l */:\n    case 0x68/* h */:\n    case 0x76/* v */:\n    case 0x63/* c */:\n    case 0x73/* s */:\n    case 0x71/* q */:\n    case 0x74/* t */:\n    case 0x61/* a */:\n    case 0x72/* r */:\n      return true;\n  }\n  return false;\n}\n\nfunction isArc(code) {\n  return (code | 0x20) === 0x61;\n}\n\nfunction isDigit(code) {\n  return (code >= 48 && code <= 57);   // 0..9\n}\n\nfunction isDigitStart(code) {\n  return (code >= 48 && code <= 57) || /* 0..9 */\n          code === 0x2B || /* + */\n          code === 0x2D || /* - */\n          code === 0x2E;   /* . */\n}\n\n\nfunction State(path) {\n  this.index  = 0;\n  this.path   = path;\n  this.max    = path.length;\n  this.result = [];\n  this.param  = 0.0;\n  this.err    = '';\n  this.segmentStart = 0;\n  this.data   = [];\n}\n\nfunction skipSpaces(state) {\n  while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {\n    state.index++;\n  }\n}\n\n\nfunction scanFlag(state) {\n  var ch = state.path.charCodeAt(state.index);\n\n  if (ch === 0x30/* 0 */) {\n    state.param = 0;\n    state.index++;\n    return;\n  }\n\n  if (ch === 0x31/* 1 */) {\n    state.param = 1;\n    state.index++;\n    return;\n  }\n\n  state.err = 'SvgPath: arc flag can be 0 or 1 only (at pos ' + state.index + ')';\n}\n\n\nfunction scanParam(state) {\n  var start = state.index,\n      index = start,\n      max = state.max,\n      zeroFirst = false,\n      hasCeiling = false,\n      hasDecimal = false,\n      hasDot = false,\n      ch;\n\n  if (index >= max) {\n    state.err = 'SvgPath: missed param (at pos ' + index + ')';\n    return;\n  }\n  ch = state.path.charCodeAt(index);\n\n  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n    index++;\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  //\n  if (!isDigit(ch) && ch !== 0x2E/* . */) {\n    state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    return;\n  }\n\n  if (ch !== 0x2E/* . */) {\n    zeroFirst = (ch === 0x30/* 0 */);\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        state.err = 'SvgPath: numbers started with `0` such as `09` are illegal (at pos ' + start + ')';\n        return;\n      }\n    }\n\n    while (index < max && isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasCeiling = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x2E/* . */) {\n    hasDot = true;\n    index++;\n    while (isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasDecimal = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x65/* e */ || ch === 0x45/* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      index++;\n    }\n    if (index < max && isDigit(state.path.charCodeAt(index))) {\n      while (index < max && isDigit(state.path.charCodeAt(index))) {\n        index++;\n      }\n    } else {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n  }\n\n  state.index = index;\n  state.param = parseFloat(state.path.slice(start, index)) + 0.0;\n}\n\n\nfunction finalizeSegment(state) {\n  var cmd, cmdLC;\n\n  // Process duplicated commands (without comand name)\n\n  // This logic is shamelessly borrowed from Raphael\n  // https://github.com/DmitryBaranovskiy/raphael/\n  //\n  cmd   = state.path[state.segmentStart];\n  cmdLC = cmd.toLowerCase();\n\n  var params = state.data;\n\n  if (cmdLC === 'm' && params.length > 2) {\n    state.result.push([ cmd, params[0], params[1] ]);\n    params = params.slice(2);\n    cmdLC = 'l';\n    cmd = (cmd === 'm') ? 'l' : 'L';\n  }\n\n  if (cmdLC === 'r') {\n    state.result.push([ cmd ].concat(params));\n  } else {\n\n    while (params.length >= paramCounts[cmdLC]) {\n      state.result.push([ cmd ].concat(params.splice(0, paramCounts[cmdLC])));\n      if (!paramCounts[cmdLC]) {\n        break;\n      }\n    }\n  }\n}\n\n\nfunction scanSegment(state) {\n  var max = state.max,\n      cmdCode, is_arc, comma_found, need_params, i;\n\n  state.segmentStart = state.index;\n  cmdCode = state.path.charCodeAt(state.index);\n  is_arc = isArc(cmdCode);\n\n  if (!isCommand(cmdCode)) {\n    state.err = 'SvgPath: bad command ' + state.path[state.index] + ' (at pos ' + state.index + ')';\n    return;\n  }\n\n  need_params = paramCounts[state.path[state.index].toLowerCase()];\n\n  state.index++;\n  skipSpaces(state);\n\n  state.data = [];\n\n  if (!need_params) {\n    // Z\n    finalizeSegment(state);\n    return;\n  }\n\n  comma_found = false;\n\n  for (;;) {\n    for (i = need_params; i > 0; i--) {\n      if (is_arc && (i === 3 || i === 4)) scanFlag(state);\n      else scanParam(state);\n\n      if (state.err.length) {\n        finalizeSegment(state);\n        return;\n      }\n      state.data.push(state.param);\n\n      skipSpaces(state);\n      comma_found = false;\n\n      if (state.index < max && state.path.charCodeAt(state.index) === 0x2C/* , */) {\n        state.index++;\n        skipSpaces(state);\n        comma_found = true;\n      }\n    }\n\n    // after ',' param is mandatory\n    if (comma_found) {\n      continue;\n    }\n\n    if (state.index >= state.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(state.path.charCodeAt(state.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(state);\n}\n\n\n/* Returns array of segments:\n *\n * [\n *   [ command, coord1, coord2, ... ]\n * ]\n */\nmodule.exports = function pathParse(svgPath) {\n  var state = new State(svgPath);\n  var max = state.max;\n\n  skipSpaces(state);\n\n  while (state.index < max && !state.err.length) {\n    scanSegment(state);\n  }\n\n  if (state.result.length) {\n    if ('mM'.indexOf(state.result[0][0]) < 0) {\n      state.err = 'SvgPath: string should start with `M` or `m`';\n      state.result = [];\n    } else {\n      state.result[0][0] = 'M';\n    }\n  }\n\n  return {\n    err: state.err,\n    segments: state.result\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvcGF0aF9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7O0FBR2Isb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1QsMEJBQTBCLE9BQU87QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb3VuZGJvYXJkLy4vbm9kZV9tb2R1bGVzL3N2Z3BhdGgvbGliL3BhdGhfcGFyc2UuanM/ZTJiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIHBhcmFtQ291bnRzID0geyBhOiA3LCBjOiA2LCBoOiAxLCBsOiAyLCBtOiAyLCByOiA0LCBxOiA0LCBzOiA0LCB0OiAyLCB2OiAxLCB6OiAwIH07XG5cbnZhciBTUEVDSUFMX1NQQUNFUyA9IFtcbiAgMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNixcbiAgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZcbl07XG5cbmZ1bmN0aW9uIGlzU3BhY2UoY2gpIHtcbiAgcmV0dXJuIChjaCA9PT0gMHgwQSkgfHwgKGNoID09PSAweDBEKSB8fCAoY2ggPT09IDB4MjAyOCkgfHwgKGNoID09PSAweDIwMjkpIHx8IC8vIExpbmUgdGVybWluYXRvcnNcbiAgICAvLyBXaGl0ZSBzcGFjZXNcbiAgICAoY2ggPT09IDB4MjApIHx8IChjaCA9PT0gMHgwOSkgfHwgKGNoID09PSAweDBCKSB8fCAoY2ggPT09IDB4MEMpIHx8IChjaCA9PT0gMHhBMCkgfHxcbiAgICAoY2ggPj0gMHgxNjgwICYmIFNQRUNJQUxfU1BBQ0VTLmluZGV4T2YoY2gpID49IDApO1xufVxuXG5mdW5jdGlvbiBpc0NvbW1hbmQoY29kZSkge1xuICAvKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuICBzd2l0Y2ggKGNvZGUgfCAweDIwKSB7XG4gICAgY2FzZSAweDZELyogbSAqLzpcbiAgICBjYXNlIDB4N0EvKiB6ICovOlxuICAgIGNhc2UgMHg2Qy8qIGwgKi86XG4gICAgY2FzZSAweDY4LyogaCAqLzpcbiAgICBjYXNlIDB4NzYvKiB2ICovOlxuICAgIGNhc2UgMHg2My8qIGMgKi86XG4gICAgY2FzZSAweDczLyogcyAqLzpcbiAgICBjYXNlIDB4NzEvKiBxICovOlxuICAgIGNhc2UgMHg3NC8qIHQgKi86XG4gICAgY2FzZSAweDYxLyogYSAqLzpcbiAgICBjYXNlIDB4NzIvKiByICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0FyYyhjb2RlKSB7XG4gIHJldHVybiAoY29kZSB8IDB4MjApID09PSAweDYxO1xufVxuXG5mdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgcmV0dXJuIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpOyAgIC8vIDAuLjlcbn1cblxuZnVuY3Rpb24gaXNEaWdpdFN0YXJ0KGNvZGUpIHtcbiAgcmV0dXJuIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8IC8qIDAuLjkgKi9cbiAgICAgICAgICBjb2RlID09PSAweDJCIHx8IC8qICsgKi9cbiAgICAgICAgICBjb2RlID09PSAweDJEIHx8IC8qIC0gKi9cbiAgICAgICAgICBjb2RlID09PSAweDJFOyAgIC8qIC4gKi9cbn1cblxuXG5mdW5jdGlvbiBTdGF0ZShwYXRoKSB7XG4gIHRoaXMuaW5kZXggID0gMDtcbiAgdGhpcy5wYXRoICAgPSBwYXRoO1xuICB0aGlzLm1heCAgICA9IHBhdGgubGVuZ3RoO1xuICB0aGlzLnJlc3VsdCA9IFtdO1xuICB0aGlzLnBhcmFtICA9IDAuMDtcbiAgdGhpcy5lcnIgICAgPSAnJztcbiAgdGhpcy5zZWdtZW50U3RhcnQgPSAwO1xuICB0aGlzLmRhdGEgICA9IFtdO1xufVxuXG5mdW5jdGlvbiBza2lwU3BhY2VzKHN0YXRlKSB7XG4gIHdoaWxlIChzdGF0ZS5pbmRleCA8IHN0YXRlLm1heCAmJiBpc1NwYWNlKHN0YXRlLnBhdGguY2hhckNvZGVBdChzdGF0ZS5pbmRleCkpKSB7XG4gICAgc3RhdGUuaW5kZXgrKztcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNjYW5GbGFnKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLnBhdGguY2hhckNvZGVBdChzdGF0ZS5pbmRleCk7XG5cbiAgaWYgKGNoID09PSAweDMwLyogMCAqLykge1xuICAgIHN0YXRlLnBhcmFtID0gMDtcbiAgICBzdGF0ZS5pbmRleCsrO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzMS8qIDEgKi8pIHtcbiAgICBzdGF0ZS5wYXJhbSA9IDE7XG4gICAgc3RhdGUuaW5kZXgrKztcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lcnIgPSAnU3ZnUGF0aDogYXJjIGZsYWcgY2FuIGJlIDAgb3IgMSBvbmx5IChhdCBwb3MgJyArIHN0YXRlLmluZGV4ICsgJyknO1xufVxuXG5cbmZ1bmN0aW9uIHNjYW5QYXJhbShzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5pbmRleCxcbiAgICAgIGluZGV4ID0gc3RhcnQsXG4gICAgICBtYXggPSBzdGF0ZS5tYXgsXG4gICAgICB6ZXJvRmlyc3QgPSBmYWxzZSxcbiAgICAgIGhhc0NlaWxpbmcgPSBmYWxzZSxcbiAgICAgIGhhc0RlY2ltYWwgPSBmYWxzZSxcbiAgICAgIGhhc0RvdCA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKGluZGV4ID49IG1heCkge1xuICAgIHN0YXRlLmVyciA9ICdTdmdQYXRoOiBtaXNzZWQgcGFyYW0gKGF0IHBvcyAnICsgaW5kZXggKyAnKSc7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNoID0gc3RhdGUucGF0aC5jaGFyQ29kZUF0KGluZGV4KTtcblxuICBpZiAoY2ggPT09IDB4MkIvKiArICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgIGluZGV4Kys7XG4gICAgY2ggPSAoaW5kZXggPCBtYXgpID8gc3RhdGUucGF0aC5jaGFyQ29kZUF0KGluZGV4KSA6IDA7XG4gIH1cblxuICAvLyBUaGlzIGxvZ2ljIGlzIHNoYW1lbGVzc2x5IGJvcnJvd2VkIGZyb20gRXNwcmltYVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvZXNwcmltYXNcbiAgLy9cbiAgaWYgKCFpc0RpZ2l0KGNoKSAmJiBjaCAhPT0gMHgyRS8qIC4gKi8pIHtcbiAgICBzdGF0ZS5lcnIgPSAnU3ZnUGF0aDogcGFyYW0gc2hvdWxkIHN0YXJ0IHdpdGggMC4uOSBvciBgLmAgKGF0IHBvcyAnICsgaW5kZXggKyAnKSc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoICE9PSAweDJFLyogLiAqLykge1xuICAgIHplcm9GaXJzdCA9IChjaCA9PT0gMHgzMC8qIDAgKi8pO1xuICAgIGluZGV4Kys7XG5cbiAgICBjaCA9IChpbmRleCA8IG1heCkgPyBzdGF0ZS5wYXRoLmNoYXJDb2RlQXQoaW5kZXgpIDogMDtcblxuICAgIGlmICh6ZXJvRmlyc3QgJiYgaW5kZXggPCBtYXgpIHtcbiAgICAgIC8vIGRlY2ltYWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJyBzdWNoIGFzICcwOScgaXMgaWxsZWdhbC5cbiAgICAgIGlmIChjaCAmJiBpc0RpZ2l0KGNoKSkge1xuICAgICAgICBzdGF0ZS5lcnIgPSAnU3ZnUGF0aDogbnVtYmVycyBzdGFydGVkIHdpdGggYDBgIHN1Y2ggYXMgYDA5YCBhcmUgaWxsZWdhbCAoYXQgcG9zICcgKyBzdGFydCArICcpJztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpbmRleCA8IG1heCAmJiBpc0RpZ2l0KHN0YXRlLnBhdGguY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgaGFzQ2VpbGluZyA9IHRydWU7XG4gICAgfVxuICAgIGNoID0gKGluZGV4IDwgbWF4KSA/IHN0YXRlLnBhdGguY2hhckNvZGVBdChpbmRleCkgOiAwO1xuICB9XG5cbiAgaWYgKGNoID09PSAweDJFLyogLiAqLykge1xuICAgIGhhc0RvdCA9IHRydWU7XG4gICAgaW5kZXgrKztcbiAgICB3aGlsZSAoaXNEaWdpdChzdGF0ZS5wYXRoLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGhhc0RlY2ltYWwgPSB0cnVlO1xuICAgIH1cbiAgICBjaCA9IChpbmRleCA8IG1heCkgPyBzdGF0ZS5wYXRoLmNoYXJDb2RlQXQoaW5kZXgpIDogMDtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHg2NS8qIGUgKi8gfHwgY2ggPT09IDB4NDUvKiBFICovKSB7XG4gICAgaWYgKGhhc0RvdCAmJiAhaGFzQ2VpbGluZyAmJiAhaGFzRGVjaW1hbCkge1xuICAgICAgc3RhdGUuZXJyID0gJ1N2Z1BhdGg6IGludmFsaWQgZmxvYXQgZXhwb25lbnQgKGF0IHBvcyAnICsgaW5kZXggKyAnKSc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5kZXgrKztcblxuICAgIGNoID0gKGluZGV4IDwgbWF4KSA/IHN0YXRlLnBhdGguY2hhckNvZGVBdChpbmRleCkgOiAwO1xuICAgIGlmIChjaCA9PT0gMHgyQi8qICsgKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCBtYXggJiYgaXNEaWdpdChzdGF0ZS5wYXRoLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgd2hpbGUgKGluZGV4IDwgbWF4ICYmIGlzRGlnaXQoc3RhdGUucGF0aC5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuZXJyID0gJ1N2Z1BhdGg6IGludmFsaWQgZmxvYXQgZXhwb25lbnQgKGF0IHBvcyAnICsgaW5kZXggKyAnKSc7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuaW5kZXggPSBpbmRleDtcbiAgc3RhdGUucGFyYW0gPSBwYXJzZUZsb2F0KHN0YXRlLnBhdGguc2xpY2Uoc3RhcnQsIGluZGV4KSkgKyAwLjA7XG59XG5cblxuZnVuY3Rpb24gZmluYWxpemVTZWdtZW50KHN0YXRlKSB7XG4gIHZhciBjbWQsIGNtZExDO1xuXG4gIC8vIFByb2Nlc3MgZHVwbGljYXRlZCBjb21tYW5kcyAod2l0aG91dCBjb21hbmQgbmFtZSlcblxuICAvLyBUaGlzIGxvZ2ljIGlzIHNoYW1lbGVzc2x5IGJvcnJvd2VkIGZyb20gUmFwaGFlbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vRG1pdHJ5QmFyYW5vdnNraXkvcmFwaGFlbC9cbiAgLy9cbiAgY21kICAgPSBzdGF0ZS5wYXRoW3N0YXRlLnNlZ21lbnRTdGFydF07XG4gIGNtZExDID0gY21kLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHBhcmFtcyA9IHN0YXRlLmRhdGE7XG5cbiAgaWYgKGNtZExDID09PSAnbScgJiYgcGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICBzdGF0ZS5yZXN1bHQucHVzaChbIGNtZCwgcGFyYW1zWzBdLCBwYXJhbXNbMV0gXSk7XG4gICAgcGFyYW1zID0gcGFyYW1zLnNsaWNlKDIpO1xuICAgIGNtZExDID0gJ2wnO1xuICAgIGNtZCA9IChjbWQgPT09ICdtJykgPyAnbCcgOiAnTCc7XG4gIH1cblxuICBpZiAoY21kTEMgPT09ICdyJykge1xuICAgIHN0YXRlLnJlc3VsdC5wdXNoKFsgY21kIF0uY29uY2F0KHBhcmFtcykpO1xuICB9IGVsc2Uge1xuXG4gICAgd2hpbGUgKHBhcmFtcy5sZW5ndGggPj0gcGFyYW1Db3VudHNbY21kTENdKSB7XG4gICAgICBzdGF0ZS5yZXN1bHQucHVzaChbIGNtZCBdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIHBhcmFtQ291bnRzW2NtZExDXSkpKTtcbiAgICAgIGlmICghcGFyYW1Db3VudHNbY21kTENdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNjYW5TZWdtZW50KHN0YXRlKSB7XG4gIHZhciBtYXggPSBzdGF0ZS5tYXgsXG4gICAgICBjbWRDb2RlLCBpc19hcmMsIGNvbW1hX2ZvdW5kLCBuZWVkX3BhcmFtcywgaTtcblxuICBzdGF0ZS5zZWdtZW50U3RhcnQgPSBzdGF0ZS5pbmRleDtcbiAgY21kQ29kZSA9IHN0YXRlLnBhdGguY2hhckNvZGVBdChzdGF0ZS5pbmRleCk7XG4gIGlzX2FyYyA9IGlzQXJjKGNtZENvZGUpO1xuXG4gIGlmICghaXNDb21tYW5kKGNtZENvZGUpKSB7XG4gICAgc3RhdGUuZXJyID0gJ1N2Z1BhdGg6IGJhZCBjb21tYW5kICcgKyBzdGF0ZS5wYXRoW3N0YXRlLmluZGV4XSArICcgKGF0IHBvcyAnICsgc3RhdGUuaW5kZXggKyAnKSc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbmVlZF9wYXJhbXMgPSBwYXJhbUNvdW50c1tzdGF0ZS5wYXRoW3N0YXRlLmluZGV4XS50b0xvd2VyQ2FzZSgpXTtcblxuICBzdGF0ZS5pbmRleCsrO1xuICBza2lwU3BhY2VzKHN0YXRlKTtcblxuICBzdGF0ZS5kYXRhID0gW107XG5cbiAgaWYgKCFuZWVkX3BhcmFtcykge1xuICAgIC8vIFpcbiAgICBmaW5hbGl6ZVNlZ21lbnQoc3RhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbW1hX2ZvdW5kID0gZmFsc2U7XG5cbiAgZm9yICg7Oykge1xuICAgIGZvciAoaSA9IG5lZWRfcGFyYW1zOyBpID4gMDsgaS0tKSB7XG4gICAgICBpZiAoaXNfYXJjICYmIChpID09PSAzIHx8IGkgPT09IDQpKSBzY2FuRmxhZyhzdGF0ZSk7XG4gICAgICBlbHNlIHNjYW5QYXJhbShzdGF0ZSk7XG5cbiAgICAgIGlmIChzdGF0ZS5lcnIubGVuZ3RoKSB7XG4gICAgICAgIGZpbmFsaXplU2VnbWVudChzdGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmRhdGEucHVzaChzdGF0ZS5wYXJhbSk7XG5cbiAgICAgIHNraXBTcGFjZXMoc3RhdGUpO1xuICAgICAgY29tbWFfZm91bmQgPSBmYWxzZTtcblxuICAgICAgaWYgKHN0YXRlLmluZGV4IDwgbWF4ICYmIHN0YXRlLnBhdGguY2hhckNvZGVBdChzdGF0ZS5pbmRleCkgPT09IDB4MkMvKiAsICovKSB7XG4gICAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgICAgIHNraXBTcGFjZXMoc3RhdGUpO1xuICAgICAgICBjb21tYV9mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWZ0ZXIgJywnIHBhcmFtIGlzIG1hbmRhdG9yeVxuICAgIGlmIChjb21tYV9mb3VuZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmluZGV4ID49IHN0YXRlLm1heCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gU3RvcCBvbiBuZXh0IHNlZ21lbnRcbiAgICBpZiAoIWlzRGlnaXRTdGFydChzdGF0ZS5wYXRoLmNoYXJDb2RlQXQoc3RhdGUuaW5kZXgpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZmluYWxpemVTZWdtZW50KHN0YXRlKTtcbn1cblxuXG4vKiBSZXR1cm5zIGFycmF5IG9mIHNlZ21lbnRzOlxuICpcbiAqIFtcbiAqICAgWyBjb21tYW5kLCBjb29yZDEsIGNvb3JkMiwgLi4uIF1cbiAqIF1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXRoUGFyc2Uoc3ZnUGF0aCkge1xuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoc3ZnUGF0aCk7XG4gIHZhciBtYXggPSBzdGF0ZS5tYXg7XG5cbiAgc2tpcFNwYWNlcyhzdGF0ZSk7XG5cbiAgd2hpbGUgKHN0YXRlLmluZGV4IDwgbWF4ICYmICFzdGF0ZS5lcnIubGVuZ3RoKSB7XG4gICAgc2NhblNlZ21lbnQoc3RhdGUpO1xuICB9XG5cbiAgaWYgKHN0YXRlLnJlc3VsdC5sZW5ndGgpIHtcbiAgICBpZiAoJ21NJy5pbmRleE9mKHN0YXRlLnJlc3VsdFswXVswXSkgPCAwKSB7XG4gICAgICBzdGF0ZS5lcnIgPSAnU3ZnUGF0aDogc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIGBNYCBvciBgbWAnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnJlc3VsdFswXVswXSA9ICdNJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVycjogc3RhdGUuZXJyLFxuICAgIHNlZ21lbnRzOiBzdGF0ZS5yZXN1bHRcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/svgpath/lib/path_parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/svgpath/lib/svgpath.js":
/*!*********************************************!*\
  !*** ./node_modules/svgpath/lib/svgpath.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// SVG Path transformations library\n//\n// Usage:\n//\n//    SvgPath('...')\n//      .translate(-150, -100)\n//      .scale(0.5)\n//      .translate(-150, -100)\n//      .toFixed(1)\n//      .toString()\n//\n\n\n\n\nvar pathParse      = __webpack_require__(/*! ./path_parse */ \"(ssr)/./node_modules/svgpath/lib/path_parse.js\");\nvar transformParse = __webpack_require__(/*! ./transform_parse */ \"(ssr)/./node_modules/svgpath/lib/transform_parse.js\");\nvar matrix         = __webpack_require__(/*! ./matrix */ \"(ssr)/./node_modules/svgpath/lib/matrix.js\");\nvar a2c            = __webpack_require__(/*! ./a2c */ \"(ssr)/./node_modules/svgpath/lib/a2c.js\");\nvar ellipse        = __webpack_require__(/*! ./ellipse */ \"(ssr)/./node_modules/svgpath/lib/ellipse.js\");\n\n\n// Class constructor\n//\nfunction SvgPath(path) {\n  if (!(this instanceof SvgPath)) { return new SvgPath(path); }\n\n  var pstate = pathParse(path);\n\n  // Array of path segments.\n  // Each segment is array [command, param1, param2, ...]\n  this.segments = pstate.segments;\n\n  // Error message on parse error.\n  this.err      = pstate.err;\n\n  // Transforms stack for lazy evaluation\n  this.__stack    = [];\n}\n\nSvgPath.from = function (src) {\n  if (typeof src === 'string') return new SvgPath(src);\n\n  if (src instanceof SvgPath) {\n    // Create empty object\n    var s = new SvgPath('');\n\n    // Clone properies\n    s.err = src.err;\n    s.segments = src.segments.map(function (sgm) { return sgm.slice(); });\n    s.__stack = src.__stack.map(function (m) {\n      return matrix().matrix(m.toArray());\n    });\n\n    return s;\n  }\n\n  throw new Error('SvgPath.from: invalid param type ' + src);\n};\n\n\nSvgPath.prototype.__matrix = function (m) {\n  var self = this, i;\n\n  // Quick leave for empty matrix\n  if (!m.queue.length) { return; }\n\n  this.iterate(function (s, index, x, y) {\n    var p, result, name, isRelative;\n\n    switch (s[0]) {\n\n      // Process 'assymetric' commands separately\n      case 'v':\n        p      = m.calc(0, s[1], true);\n        result = (p[0] === 0) ? [ 'v', p[1] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'V':\n        p      = m.calc(x, s[1], false);\n        result = (p[0] === m.calc(x, y, false)[0]) ? [ 'V', p[1] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'h':\n        p      = m.calc(s[1], 0, true);\n        result = (p[1] === 0) ? [ 'h', p[0] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'H':\n        p      = m.calc(s[1], y, false);\n        result = (p[1] === m.calc(x, y, false)[1]) ? [ 'H', p[0] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'a':\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n\n        // Drop segment if arc is empty (end point === start point)\n        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          return [];\n        }*/\n\n        // Transform rx, ry and the x-axis-rotation\n        var ma = m.toArray();\n        var e = ellipse(s[1], s[2], s[3]).transform(ma);\n\n        // flip sweep-flag if matrix is not orientation-preserving\n        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {\n          s[5] = s[5] ? '0' : '1';\n        }\n\n        // Transform end point as usual (without translation for relative notation)\n        p = m.calc(s[6], s[7], s[0] === 'a');\n\n        // Empty arcs can be ignored by renderer, but should not be dropped\n        // to avoid collisions with `S A S` and so on. Replace with empty line.\n        if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n          break;\n        }\n\n        // if the resulting ellipse is (almost) a segment ...\n        if (e.isDegenerate()) {\n          // replace the arc by a line\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n        } else {\n          // if it is a real ellipse\n          // s[0], s[4] and s[5] are not modified\n          result = [ s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1] ];\n        }\n\n        break;\n\n      case 'm':\n        // Edge case. The very first `m` should be processed as absolute, if happens.\n        // Make sense for coord shift transforms.\n        isRelative = index > 0;\n\n        p = m.calc(s[1], s[2], isRelative);\n        result = [ 'm', p[0], p[1] ];\n        break;\n\n      default:\n        name       = s[0];\n        result     = [ name ];\n        isRelative = (name.toLowerCase() === name);\n\n        // Apply transformations to the segment\n        for (i = 1; i < s.length; i += 2) {\n          p = m.calc(s[i], s[i + 1], isRelative);\n          result.push(p[0], p[1]);\n        }\n    }\n\n    self.segments[index] = result;\n  }, true);\n};\n\n\n// Apply stacked commands\n//\nSvgPath.prototype.__evaluateStack = function () {\n  var m, i;\n\n  if (!this.__stack.length) { return; }\n\n  if (this.__stack.length === 1) {\n    this.__matrix(this.__stack[0]);\n    this.__stack = [];\n    return;\n  }\n\n  m = matrix();\n  i = this.__stack.length;\n\n  while (--i >= 0) {\n    m.matrix(this.__stack[i].toArray());\n  }\n\n  this.__matrix(m);\n  this.__stack = [];\n};\n\n\n// Convert processed SVG Path back to string\n//\nSvgPath.prototype.toString = function () {\n  var result = '', prevCmd = '', cmdSkipped = false;\n\n  this.__evaluateStack();\n\n  for (var i = 0, len = this.segments.length; i < len; i++) {\n    var segment = this.segments[i];\n    var cmd = segment[0];\n\n    // Command not repeating => store\n    if (cmd !== prevCmd || cmd === 'm' || cmd === 'M') {\n      // workaround for FontForge SVG importing bug, keep space between \"z m\".\n      if (cmd === 'm' && prevCmd === 'z') result += ' ';\n      result += cmd;\n\n      cmdSkipped = false;\n    } else {\n      cmdSkipped = true;\n    }\n\n    // Store segment params\n    for (var pos = 1; pos < segment.length; pos++) {\n      var val = segment[pos];\n      // Space can be skipped\n      // 1. After command (always)\n      // 2. For negative value (with '-' at start)\n      if (pos === 1) {\n        if (cmdSkipped && val >= 0) result += ' ';\n      } else if (val >= 0) result += ' ';\n\n      result += val;\n    }\n\n    prevCmd = cmd;\n  }\n\n  return result;\n};\n\n\n// Translate path to (x [, y])\n//\nSvgPath.prototype.translate = function (x, y) {\n  this.__stack.push(matrix().translate(x, y || 0));\n  return this;\n};\n\n\n// Scale path to (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.scale = function (sx, sy) {\n  this.__stack.push(matrix().scale(sx, (!sy && (sy !== 0)) ? sx : sy));\n  return this;\n};\n\n\n// Rotate path around point (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.rotate = function (angle, rx, ry) {\n  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));\n  return this;\n};\n\n\n// Skew path along the X axis by `degrees` angle\n//\nSvgPath.prototype.skewX = function (degrees) {\n  this.__stack.push(matrix().skewX(degrees));\n  return this;\n};\n\n\n// Skew path along the Y axis by `degrees` angle\n//\nSvgPath.prototype.skewY = function (degrees) {\n  this.__stack.push(matrix().skewY(degrees));\n  return this;\n};\n\n\n// Apply matrix transform (array of 6 elements)\n//\nSvgPath.prototype.matrix = function (m) {\n  this.__stack.push(matrix().matrix(m));\n  return this;\n};\n\n\n// Transform path according to \"transform\" attr of SVG spec\n//\nSvgPath.prototype.transform = function (transformString) {\n  if (!transformString.trim()) {\n    return this;\n  }\n  this.__stack.push(transformParse(transformString));\n  return this;\n};\n\n\n// Round coords with given decimal precition.\n// 0 by default (to integers)\n//\nSvgPath.prototype.round = function (d) {\n  var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l;\n\n  d = d || 0;\n\n  this.__evaluateStack();\n\n  this.segments.forEach(function (s) {\n    var isRelative = (s[0].toLowerCase() === s[0]);\n\n    switch (s[0]) {\n      case 'H':\n      case 'h':\n        if (isRelative) { s[1] += deltaX; }\n        deltaX = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'V':\n      case 'v':\n        if (isRelative) { s[1] += deltaY; }\n        deltaY = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'Z':\n      case 'z':\n        deltaX = contourStartDeltaX;\n        deltaY = contourStartDeltaY;\n        return;\n\n      case 'M':\n      case 'm':\n        if (isRelative) {\n          s[1] += deltaX;\n          s[2] += deltaY;\n        }\n\n        deltaX = s[1] - s[1].toFixed(d);\n        deltaY = s[2] - s[2].toFixed(d);\n\n        contourStartDeltaX = deltaX;\n        contourStartDeltaY = deltaY;\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        return;\n\n      case 'A':\n      case 'a':\n        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        if (isRelative) {\n          s[6] += deltaX;\n          s[7] += deltaY;\n        }\n\n        deltaX = s[6] - s[6].toFixed(d);\n        deltaY = s[7] - s[7].toFixed(d);\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        s[3] = +s[3].toFixed(d + 2); // better precision for rotation\n        s[6] = +s[6].toFixed(d);\n        s[7] = +s[7].toFixed(d);\n        return;\n\n      default:\n        // a c l q s t\n        l = s.length;\n\n        if (isRelative) {\n          s[l - 2] += deltaX;\n          s[l - 1] += deltaY;\n        }\n\n        deltaX = s[l - 2] - s[l - 2].toFixed(d);\n        deltaY = s[l - 1] - s[l - 1].toFixed(d);\n\n        s.forEach(function (val, i) {\n          if (!i) { return; }\n          s[i] = +s[i].toFixed(d);\n        });\n        return;\n    }\n  });\n\n  return this;\n};\n\n\n// Apply iterator function to all segments. If function returns result,\n// current segment will be replaced to array of returned segments.\n// If empty array is returned, current regment will be deleted.\n//\nSvgPath.prototype.iterate = function (iterator, keepLazyStack) {\n  var segments = this.segments,\n      replacements = {},\n      needReplace = false,\n      lastX = 0,\n      lastY = 0,\n      countourStartX = 0,\n      countourStartY = 0;\n  var i, j, newSegments;\n\n  if (!keepLazyStack) {\n    this.__evaluateStack();\n  }\n\n  segments.forEach(function (s, index) {\n\n    var res = iterator(s, index, lastX, lastY);\n\n    if (Array.isArray(res)) {\n      replacements[index] = res;\n      needReplace = true;\n    }\n\n    var isRelative = (s[0] === s[0].toLowerCase());\n\n    // calculate absolute X and Y\n    switch (s[0]) {\n      case 'm':\n      case 'M':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        lastY = s[2] + (isRelative ? lastY : 0);\n        countourStartX = lastX;\n        countourStartY = lastY;\n        return;\n\n      case 'h':\n      case 'H':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        return;\n\n      case 'v':\n      case 'V':\n        lastY = s[1] + (isRelative ? lastY : 0);\n        return;\n\n      case 'z':\n      case 'Z':\n        // That make sence for multiple contours\n        lastX = countourStartX;\n        lastY = countourStartY;\n        return;\n\n      default:\n        lastX = s[s.length - 2] + (isRelative ? lastX : 0);\n        lastY = s[s.length - 1] + (isRelative ? lastY : 0);\n    }\n  });\n\n  // Replace segments if iterator return results\n\n  if (!needReplace) { return this; }\n\n  newSegments = [];\n\n  for (i = 0; i < segments.length; i++) {\n    if (typeof replacements[i] !== 'undefined') {\n      for (j = 0; j < replacements[i].length; j++) {\n        newSegments.push(replacements[i][j]);\n      }\n    } else {\n      newSegments.push(segments[i]);\n    }\n  }\n\n  this.segments = newSegments;\n\n  return this;\n};\n\n\n// Converts segments from relative to absolute\n//\nSvgPath.prototype.abs = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameUC = name.toUpperCase(),\n        i;\n\n    // Skip absolute commands\n    if (name === nameUC) { return; }\n\n    s[0] = nameUC;\n\n    switch (name) {\n      case 'v':\n        // v has shifted coords parity\n        s[1] += y;\n        return;\n\n      case 'a':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] += x;\n        s[7] += y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] += i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts segments from absolute to relative\n//\nSvgPath.prototype.rel = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameLC = name.toLowerCase(),\n        i;\n\n    // Skip relative commands\n    if (name === nameLC) { return; }\n\n    // Don't touch the first M to avoid potential confusions.\n    if (index === 0 && name === 'M') { return; }\n\n    s[0] = nameLC;\n\n    switch (name) {\n      case 'V':\n        // V has shifted coords parity\n        s[1] -= y;\n        return;\n\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] -= x;\n        s[7] -= y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] -= i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts arcs to cubic bézier curves\n//\nSvgPath.prototype.unarc = function () {\n  this.iterate(function (s, index, x, y) {\n    var new_segments, nextX, nextY, result = [], name = s[0];\n\n    // Skip anything except arcs\n    if (name !== 'A' && name !== 'a') { return null; }\n\n    if (name === 'a') {\n      // convert relative arc coordinates to absolute\n      nextX = x + s[6];\n      nextY = y + s[7];\n    } else {\n      nextX = s[6];\n      nextY = s[7];\n    }\n\n    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);\n\n    // Degenerated arcs can be ignored by renderer, but should not be dropped\n    // to avoid collisions with `S A S` and so on. Replace with empty line.\n    if (new_segments.length === 0) {\n      return [ [ s[0] === 'a' ? 'l' : 'L', s[6], s[7] ] ];\n    }\n\n    new_segments.forEach(function (s) {\n      result.push([ 'C', s[2], s[3], s[4], s[5], s[6], s[7] ]);\n    });\n\n    return result;\n  });\n\n  return this;\n};\n\n\n// Converts smooth curves (with missed control point) to generic curves\n//\nSvgPath.prototype.unshort = function () {\n  var segments = this.segments;\n  var prevControlX, prevControlY, prevSegment;\n  var curControlX, curControlY;\n\n  // TODO: add lazy evaluation flag when relative commands supported\n\n  this.iterate(function (s, idx, x, y) {\n    var name = s[0], nameUC = name.toUpperCase(), isRelative;\n\n    // First command MUST be M|m, it's safe to skip.\n    // Protect from access to [-1] for sure.\n    if (!idx) { return; }\n\n    if (nameUC === 'T') { // quadratic curve\n      isRelative = (name === 't');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'Q') {\n        prevControlX = prevSegment[1] - x;\n        prevControlY = prevSegment[2] - y;\n      } else if (prevSegment[0] === 'q') {\n        prevControlX = prevSegment[1] - prevSegment[3];\n        prevControlY = prevSegment[2] - prevSegment[4];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'q' : 'Q',\n        curControlX, curControlY,\n        s[1], s[2]\n      ];\n\n    } else if (nameUC === 'S') { // cubic curve\n      isRelative = (name === 's');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'C') {\n        prevControlX = prevSegment[3] - x;\n        prevControlY = prevSegment[4] - y;\n      } else if (prevSegment[0] === 'c') {\n        prevControlX = prevSegment[3] - prevSegment[5];\n        prevControlY = prevSegment[4] - prevSegment[6];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'c' : 'C',\n        curControlX, curControlY,\n        s[1], s[2], s[3], s[4]\n      ];\n    }\n  });\n\n  return this;\n};\n\n\nmodule.exports = SvgPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvc3ZncGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7QUFHYixxQkFBcUIsbUJBQU8sQ0FBQyxvRUFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDaEQscUJBQXFCLG1CQUFPLENBQUMsNERBQVU7QUFDdkMscUJBQXFCLG1CQUFPLENBQUMsc0RBQU87QUFDcEMscUJBQXFCLG1CQUFPLENBQUMsOERBQVc7OztBQUd4QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELHFCQUFxQjtBQUN4RTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBLHNCQUFzQjs7QUFFdEI7O0FBRUEsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLHVDQUF1Qzs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLDBCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sMkJBQTJCO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb3VuZGJvYXJkLy4vbm9kZV9tb2R1bGVzL3N2Z3BhdGgvbGliL3N2Z3BhdGguanM/ODQwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTVkcgUGF0aCB0cmFuc2Zvcm1hdGlvbnMgbGlicmFyeVxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vICAgIFN2Z1BhdGgoJy4uLicpXG4vLyAgICAgIC50cmFuc2xhdGUoLTE1MCwgLTEwMClcbi8vICAgICAgLnNjYWxlKDAuNSlcbi8vICAgICAgLnRyYW5zbGF0ZSgtMTUwLCAtMTAwKVxuLy8gICAgICAudG9GaXhlZCgxKVxuLy8gICAgICAudG9TdHJpbmcoKVxuLy9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBwYXRoUGFyc2UgICAgICA9IHJlcXVpcmUoJy4vcGF0aF9wYXJzZScpO1xudmFyIHRyYW5zZm9ybVBhcnNlID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1fcGFyc2UnKTtcbnZhciBtYXRyaXggICAgICAgICA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG52YXIgYTJjICAgICAgICAgICAgPSByZXF1aXJlKCcuL2EyYycpO1xudmFyIGVsbGlwc2UgICAgICAgID0gcmVxdWlyZSgnLi9lbGxpcHNlJyk7XG5cblxuLy8gQ2xhc3MgY29uc3RydWN0b3Jcbi8vXG5mdW5jdGlvbiBTdmdQYXRoKHBhdGgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN2Z1BhdGgpKSB7IHJldHVybiBuZXcgU3ZnUGF0aChwYXRoKTsgfVxuXG4gIHZhciBwc3RhdGUgPSBwYXRoUGFyc2UocGF0aCk7XG5cbiAgLy8gQXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgLy8gRWFjaCBzZWdtZW50IGlzIGFycmF5IFtjb21tYW5kLCBwYXJhbTEsIHBhcmFtMiwgLi4uXVxuICB0aGlzLnNlZ21lbnRzID0gcHN0YXRlLnNlZ21lbnRzO1xuXG4gIC8vIEVycm9yIG1lc3NhZ2Ugb24gcGFyc2UgZXJyb3IuXG4gIHRoaXMuZXJyICAgICAgPSBwc3RhdGUuZXJyO1xuXG4gIC8vIFRyYW5zZm9ybXMgc3RhY2sgZm9yIGxhenkgZXZhbHVhdGlvblxuICB0aGlzLl9fc3RhY2sgICAgPSBbXTtcbn1cblxuU3ZnUGF0aC5mcm9tID0gZnVuY3Rpb24gKHNyYykge1xuICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHJldHVybiBuZXcgU3ZnUGF0aChzcmMpO1xuXG4gIGlmIChzcmMgaW5zdGFuY2VvZiBTdmdQYXRoKSB7XG4gICAgLy8gQ3JlYXRlIGVtcHR5IG9iamVjdFxuICAgIHZhciBzID0gbmV3IFN2Z1BhdGgoJycpO1xuXG4gICAgLy8gQ2xvbmUgcHJvcGVyaWVzXG4gICAgcy5lcnIgPSBzcmMuZXJyO1xuICAgIHMuc2VnbWVudHMgPSBzcmMuc2VnbWVudHMubWFwKGZ1bmN0aW9uIChzZ20pIHsgcmV0dXJuIHNnbS5zbGljZSgpOyB9KTtcbiAgICBzLl9fc3RhY2sgPSBzcmMuX19zdGFjay5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtYXRyaXgoKS5tYXRyaXgobS50b0FycmF5KCkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1N2Z1BhdGguZnJvbTogaW52YWxpZCBwYXJhbSB0eXBlICcgKyBzcmMpO1xufTtcblxuXG5TdmdQYXRoLnByb3RvdHlwZS5fX21hdHJpeCA9IGZ1bmN0aW9uIChtKSB7XG4gIHZhciBzZWxmID0gdGhpcywgaTtcblxuICAvLyBRdWljayBsZWF2ZSBmb3IgZW1wdHkgbWF0cml4XG4gIGlmICghbS5xdWV1ZS5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cbiAgdGhpcy5pdGVyYXRlKGZ1bmN0aW9uIChzLCBpbmRleCwgeCwgeSkge1xuICAgIHZhciBwLCByZXN1bHQsIG5hbWUsIGlzUmVsYXRpdmU7XG5cbiAgICBzd2l0Y2ggKHNbMF0pIHtcblxuICAgICAgLy8gUHJvY2VzcyAnYXNzeW1ldHJpYycgY29tbWFuZHMgc2VwYXJhdGVseVxuICAgICAgY2FzZSAndic6XG4gICAgICAgIHAgICAgICA9IG0uY2FsYygwLCBzWzFdLCB0cnVlKTtcbiAgICAgICAgcmVzdWx0ID0gKHBbMF0gPT09IDApID8gWyAndicsIHBbMV0gXSA6IFsgJ2wnLCBwWzBdLCBwWzFdIF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzpcbiAgICAgICAgcCAgICAgID0gbS5jYWxjKHgsIHNbMV0sIGZhbHNlKTtcbiAgICAgICAgcmVzdWx0ID0gKHBbMF0gPT09IG0uY2FsYyh4LCB5LCBmYWxzZSlbMF0pID8gWyAnVicsIHBbMV0gXSA6IFsgJ0wnLCBwWzBdLCBwWzFdIF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoJzpcbiAgICAgICAgcCAgICAgID0gbS5jYWxjKHNbMV0sIDAsIHRydWUpO1xuICAgICAgICByZXN1bHQgPSAocFsxXSA9PT0gMCkgPyBbICdoJywgcFswXSBdIDogWyAnbCcsIHBbMF0sIHBbMV0gXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICBwICAgICAgPSBtLmNhbGMoc1sxXSwgeSwgZmFsc2UpO1xuICAgICAgICByZXN1bHQgPSAocFsxXSA9PT0gbS5jYWxjKHgsIHksIGZhbHNlKVsxXSkgPyBbICdIJywgcFswXSBdIDogWyAnTCcsIHBbMF0sIHBbMV0gXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIC8vIEFSQyBpczogWydBJywgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxuXG4gICAgICAgIC8vIERyb3Agc2VnbWVudCBpZiBhcmMgaXMgZW1wdHkgKGVuZCBwb2ludCA9PT0gc3RhcnQgcG9pbnQpXG4gICAgICAgIC8qaWYgKChzWzBdID09PSAnQScgJiYgc1s2XSA9PT0geCAmJiBzWzddID09PSB5KSB8fFxuICAgICAgICAgICAgKHNbMF0gPT09ICdhJyAmJiBzWzZdID09PSAwICYmIHNbN10gPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9Ki9cblxuICAgICAgICAvLyBUcmFuc2Zvcm0gcngsIHJ5IGFuZCB0aGUgeC1heGlzLXJvdGF0aW9uXG4gICAgICAgIHZhciBtYSA9IG0udG9BcnJheSgpO1xuICAgICAgICB2YXIgZSA9IGVsbGlwc2Uoc1sxXSwgc1syXSwgc1szXSkudHJhbnNmb3JtKG1hKTtcblxuICAgICAgICAvLyBmbGlwIHN3ZWVwLWZsYWcgaWYgbWF0cml4IGlzIG5vdCBvcmllbnRhdGlvbi1wcmVzZXJ2aW5nXG4gICAgICAgIGlmIChtYVswXSAqIG1hWzNdIC0gbWFbMV0gKiBtYVsyXSA8IDApIHtcbiAgICAgICAgICBzWzVdID0gc1s1XSA/ICcwJyA6ICcxJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYW5zZm9ybSBlbmQgcG9pbnQgYXMgdXN1YWwgKHdpdGhvdXQgdHJhbnNsYXRpb24gZm9yIHJlbGF0aXZlIG5vdGF0aW9uKVxuICAgICAgICBwID0gbS5jYWxjKHNbNl0sIHNbN10sIHNbMF0gPT09ICdhJyk7XG5cbiAgICAgICAgLy8gRW1wdHkgYXJjcyBjYW4gYmUgaWdub3JlZCBieSByZW5kZXJlciwgYnV0IHNob3VsZCBub3QgYmUgZHJvcHBlZFxuICAgICAgICAvLyB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggYFMgQSBTYCBhbmQgc28gb24uIFJlcGxhY2Ugd2l0aCBlbXB0eSBsaW5lLlxuICAgICAgICBpZiAoKHNbMF0gPT09ICdBJyAmJiBzWzZdID09PSB4ICYmIHNbN10gPT09IHkpIHx8XG4gICAgICAgICAgICAoc1swXSA9PT0gJ2EnICYmIHNbNl0gPT09IDAgJiYgc1s3XSA9PT0gMCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBbIHNbMF0gPT09ICdhJyA/ICdsJyA6ICdMJywgcFswXSwgcFsxXSBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHJlc3VsdGluZyBlbGxpcHNlIGlzIChhbG1vc3QpIGEgc2VnbWVudCAuLi5cbiAgICAgICAgaWYgKGUuaXNEZWdlbmVyYXRlKCkpIHtcbiAgICAgICAgICAvLyByZXBsYWNlIHRoZSBhcmMgYnkgYSBsaW5lXG4gICAgICAgICAgcmVzdWx0ID0gWyBzWzBdID09PSAnYScgPyAnbCcgOiAnTCcsIHBbMF0sIHBbMV0gXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBpdCBpcyBhIHJlYWwgZWxsaXBzZVxuICAgICAgICAgIC8vIHNbMF0sIHNbNF0gYW5kIHNbNV0gYXJlIG5vdCBtb2RpZmllZFxuICAgICAgICAgIHJlc3VsdCA9IFsgc1swXSwgZS5yeCwgZS5yeSwgZS5heCwgc1s0XSwgc1s1XSwgcFswXSwgcFsxXSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICAvLyBFZGdlIGNhc2UuIFRoZSB2ZXJ5IGZpcnN0IGBtYCBzaG91bGQgYmUgcHJvY2Vzc2VkIGFzIGFic29sdXRlLCBpZiBoYXBwZW5zLlxuICAgICAgICAvLyBNYWtlIHNlbnNlIGZvciBjb29yZCBzaGlmdCB0cmFuc2Zvcm1zLlxuICAgICAgICBpc1JlbGF0aXZlID0gaW5kZXggPiAwO1xuXG4gICAgICAgIHAgPSBtLmNhbGMoc1sxXSwgc1syXSwgaXNSZWxhdGl2ZSk7XG4gICAgICAgIHJlc3VsdCA9IFsgJ20nLCBwWzBdLCBwWzFdIF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuYW1lICAgICAgID0gc1swXTtcbiAgICAgICAgcmVzdWx0ICAgICA9IFsgbmFtZSBdO1xuICAgICAgICBpc1JlbGF0aXZlID0gKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSk7XG5cbiAgICAgICAgLy8gQXBwbHkgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBzZWdtZW50XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgcCA9IG0uY2FsYyhzW2ldLCBzW2kgKyAxXSwgaXNSZWxhdGl2ZSk7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocFswXSwgcFsxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLnNlZ21lbnRzW2luZGV4XSA9IHJlc3VsdDtcbiAgfSwgdHJ1ZSk7XG59O1xuXG5cbi8vIEFwcGx5IHN0YWNrZWQgY29tbWFuZHNcbi8vXG5TdmdQYXRoLnByb3RvdHlwZS5fX2V2YWx1YXRlU3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtLCBpO1xuXG4gIGlmICghdGhpcy5fX3N0YWNrLmxlbmd0aCkgeyByZXR1cm47IH1cblxuICBpZiAodGhpcy5fX3N0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuX19tYXRyaXgodGhpcy5fX3N0YWNrWzBdKTtcbiAgICB0aGlzLl9fc3RhY2sgPSBbXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBtID0gbWF0cml4KCk7XG4gIGkgPSB0aGlzLl9fc3RhY2subGVuZ3RoO1xuXG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIG0ubWF0cml4KHRoaXMuX19zdGFja1tpXS50b0FycmF5KCkpO1xuICB9XG5cbiAgdGhpcy5fX21hdHJpeChtKTtcbiAgdGhpcy5fX3N0YWNrID0gW107XG59O1xuXG5cbi8vIENvbnZlcnQgcHJvY2Vzc2VkIFNWRyBQYXRoIGJhY2sgdG8gc3RyaW5nXG4vL1xuU3ZnUGF0aC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXN1bHQgPSAnJywgcHJldkNtZCA9ICcnLCBjbWRTa2lwcGVkID0gZmFsc2U7XG5cbiAgdGhpcy5fX2V2YWx1YXRlU3RhY2soKTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5zZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXTtcbiAgICB2YXIgY21kID0gc2VnbWVudFswXTtcblxuICAgIC8vIENvbW1hbmQgbm90IHJlcGVhdGluZyA9PiBzdG9yZVxuICAgIGlmIChjbWQgIT09IHByZXZDbWQgfHwgY21kID09PSAnbScgfHwgY21kID09PSAnTScpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIEZvbnRGb3JnZSBTVkcgaW1wb3J0aW5nIGJ1Zywga2VlcCBzcGFjZSBiZXR3ZWVuIFwieiBtXCIuXG4gICAgICBpZiAoY21kID09PSAnbScgJiYgcHJldkNtZCA9PT0gJ3onKSByZXN1bHQgKz0gJyAnO1xuICAgICAgcmVzdWx0ICs9IGNtZDtcblxuICAgICAgY21kU2tpcHBlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbWRTa2lwcGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBzZWdtZW50IHBhcmFtc1xuICAgIGZvciAodmFyIHBvcyA9IDE7IHBvcyA8IHNlZ21lbnQubGVuZ3RoOyBwb3MrKykge1xuICAgICAgdmFyIHZhbCA9IHNlZ21lbnRbcG9zXTtcbiAgICAgIC8vIFNwYWNlIGNhbiBiZSBza2lwcGVkXG4gICAgICAvLyAxLiBBZnRlciBjb21tYW5kIChhbHdheXMpXG4gICAgICAvLyAyLiBGb3IgbmVnYXRpdmUgdmFsdWUgKHdpdGggJy0nIGF0IHN0YXJ0KVxuICAgICAgaWYgKHBvcyA9PT0gMSkge1xuICAgICAgICBpZiAoY21kU2tpcHBlZCAmJiB2YWwgPj0gMCkgcmVzdWx0ICs9ICcgJztcbiAgICAgIH0gZWxzZSBpZiAodmFsID49IDApIHJlc3VsdCArPSAnICc7XG5cbiAgICAgIHJlc3VsdCArPSB2YWw7XG4gICAgfVxuXG4gICAgcHJldkNtZCA9IGNtZDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIFRyYW5zbGF0ZSBwYXRoIHRvICh4IFssIHldKVxuLy9cblN2Z1BhdGgucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHRoaXMuX19zdGFjay5wdXNoKG1hdHJpeCgpLnRyYW5zbGF0ZSh4LCB5IHx8IDApKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIFNjYWxlIHBhdGggdG8gKHN4IFssIHN5XSlcbi8vIHN5ID0gc3ggaWYgbm90IGRlZmluZWRcbi8vXG5TdmdQYXRoLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgdGhpcy5fX3N0YWNrLnB1c2gobWF0cml4KCkuc2NhbGUoc3gsICghc3kgJiYgKHN5ICE9PSAwKSkgPyBzeCA6IHN5KSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBSb3RhdGUgcGF0aCBhcm91bmQgcG9pbnQgKHN4IFssIHN5XSlcbi8vIHN5ID0gc3ggaWYgbm90IGRlZmluZWRcbi8vXG5TdmdQYXRoLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUsIHJ4LCByeSkge1xuICB0aGlzLl9fc3RhY2sucHVzaChtYXRyaXgoKS5yb3RhdGUoYW5nbGUsIHJ4IHx8IDAsIHJ5IHx8IDApKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIFNrZXcgcGF0aCBhbG9uZyB0aGUgWCBheGlzIGJ5IGBkZWdyZWVzYCBhbmdsZVxuLy9cblN2Z1BhdGgucHJvdG90eXBlLnNrZXdYID0gZnVuY3Rpb24gKGRlZ3JlZXMpIHtcbiAgdGhpcy5fX3N0YWNrLnB1c2gobWF0cml4KCkuc2tld1goZGVncmVlcykpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gU2tldyBwYXRoIGFsb25nIHRoZSBZIGF4aXMgYnkgYGRlZ3JlZXNgIGFuZ2xlXG4vL1xuU3ZnUGF0aC5wcm90b3R5cGUuc2tld1kgPSBmdW5jdGlvbiAoZGVncmVlcykge1xuICB0aGlzLl9fc3RhY2sucHVzaChtYXRyaXgoKS5za2V3WShkZWdyZWVzKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBBcHBseSBtYXRyaXggdHJhbnNmb3JtIChhcnJheSBvZiA2IGVsZW1lbnRzKVxuLy9cblN2Z1BhdGgucHJvdG90eXBlLm1hdHJpeCA9IGZ1bmN0aW9uIChtKSB7XG4gIHRoaXMuX19zdGFjay5wdXNoKG1hdHJpeCgpLm1hdHJpeChtKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBUcmFuc2Zvcm0gcGF0aCBhY2NvcmRpbmcgdG8gXCJ0cmFuc2Zvcm1cIiBhdHRyIG9mIFNWRyBzcGVjXG4vL1xuU3ZnUGF0aC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHRyYW5zZm9ybVN0cmluZykge1xuICBpZiAoIXRyYW5zZm9ybVN0cmluZy50cmltKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9fc3RhY2sucHVzaCh0cmFuc2Zvcm1QYXJzZSh0cmFuc2Zvcm1TdHJpbmcpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIFJvdW5kIGNvb3JkcyB3aXRoIGdpdmVuIGRlY2ltYWwgcHJlY2l0aW9uLlxuLy8gMCBieSBkZWZhdWx0ICh0byBpbnRlZ2Vycylcbi8vXG5TdmdQYXRoLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uIChkKSB7XG4gIHZhciBjb250b3VyU3RhcnREZWx0YVggPSAwLCBjb250b3VyU3RhcnREZWx0YVkgPSAwLCBkZWx0YVggPSAwLCBkZWx0YVkgPSAwLCBsO1xuXG4gIGQgPSBkIHx8IDA7XG5cbiAgdGhpcy5fX2V2YWx1YXRlU3RhY2soKTtcblxuICB0aGlzLnNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgaXNSZWxhdGl2ZSA9IChzWzBdLnRvTG93ZXJDYXNlKCkgPT09IHNbMF0pO1xuXG4gICAgc3dpdGNoIChzWzBdKSB7XG4gICAgICBjYXNlICdIJzpcbiAgICAgIGNhc2UgJ2gnOlxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSkgeyBzWzFdICs9IGRlbHRhWDsgfVxuICAgICAgICBkZWx0YVggPSBzWzFdIC0gc1sxXS50b0ZpeGVkKGQpO1xuICAgICAgICBzWzFdID0gK3NbMV0udG9GaXhlZChkKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdWJzpcbiAgICAgIGNhc2UgJ3YnOlxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSkgeyBzWzFdICs9IGRlbHRhWTsgfVxuICAgICAgICBkZWx0YVkgPSBzWzFdIC0gc1sxXS50b0ZpeGVkKGQpO1xuICAgICAgICBzWzFdID0gK3NbMV0udG9GaXhlZChkKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdaJzpcbiAgICAgIGNhc2UgJ3onOlxuICAgICAgICBkZWx0YVggPSBjb250b3VyU3RhcnREZWx0YVg7XG4gICAgICAgIGRlbHRhWSA9IGNvbnRvdXJTdGFydERlbHRhWTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdNJzpcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSkge1xuICAgICAgICAgIHNbMV0gKz0gZGVsdGFYO1xuICAgICAgICAgIHNbMl0gKz0gZGVsdGFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsdGFYID0gc1sxXSAtIHNbMV0udG9GaXhlZChkKTtcbiAgICAgICAgZGVsdGFZID0gc1syXSAtIHNbMl0udG9GaXhlZChkKTtcblxuICAgICAgICBjb250b3VyU3RhcnREZWx0YVggPSBkZWx0YVg7XG4gICAgICAgIGNvbnRvdXJTdGFydERlbHRhWSA9IGRlbHRhWTtcblxuICAgICAgICBzWzFdID0gK3NbMV0udG9GaXhlZChkKTtcbiAgICAgICAgc1syXSA9ICtzWzJdLnRvRml4ZWQoZCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAnQSc6XG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gW2NtZCwgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSkge1xuICAgICAgICAgIHNbNl0gKz0gZGVsdGFYO1xuICAgICAgICAgIHNbN10gKz0gZGVsdGFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsdGFYID0gc1s2XSAtIHNbNl0udG9GaXhlZChkKTtcbiAgICAgICAgZGVsdGFZID0gc1s3XSAtIHNbN10udG9GaXhlZChkKTtcblxuICAgICAgICBzWzFdID0gK3NbMV0udG9GaXhlZChkKTtcbiAgICAgICAgc1syXSA9ICtzWzJdLnRvRml4ZWQoZCk7XG4gICAgICAgIHNbM10gPSArc1szXS50b0ZpeGVkKGQgKyAyKTsgLy8gYmV0dGVyIHByZWNpc2lvbiBmb3Igcm90YXRpb25cbiAgICAgICAgc1s2XSA9ICtzWzZdLnRvRml4ZWQoZCk7XG4gICAgICAgIHNbN10gPSArc1s3XS50b0ZpeGVkKGQpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGEgYyBsIHEgcyB0XG4gICAgICAgIGwgPSBzLmxlbmd0aDtcblxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSkge1xuICAgICAgICAgIHNbbCAtIDJdICs9IGRlbHRhWDtcbiAgICAgICAgICBzW2wgLSAxXSArPSBkZWx0YVk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWx0YVggPSBzW2wgLSAyXSAtIHNbbCAtIDJdLnRvRml4ZWQoZCk7XG4gICAgICAgIGRlbHRhWSA9IHNbbCAtIDFdIC0gc1tsIC0gMV0udG9GaXhlZChkKTtcblxuICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHZhbCwgaSkge1xuICAgICAgICAgIGlmICghaSkgeyByZXR1cm47IH1cbiAgICAgICAgICBzW2ldID0gK3NbaV0udG9GaXhlZChkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBBcHBseSBpdGVyYXRvciBmdW5jdGlvbiB0byBhbGwgc2VnbWVudHMuIElmIGZ1bmN0aW9uIHJldHVybnMgcmVzdWx0LFxuLy8gY3VycmVudCBzZWdtZW50IHdpbGwgYmUgcmVwbGFjZWQgdG8gYXJyYXkgb2YgcmV0dXJuZWQgc2VnbWVudHMuXG4vLyBJZiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCwgY3VycmVudCByZWdtZW50IHdpbGwgYmUgZGVsZXRlZC5cbi8vXG5TdmdQYXRoLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBrZWVwTGF6eVN0YWNrKSB7XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHMsXG4gICAgICByZXBsYWNlbWVudHMgPSB7fSxcbiAgICAgIG5lZWRSZXBsYWNlID0gZmFsc2UsXG4gICAgICBsYXN0WCA9IDAsXG4gICAgICBsYXN0WSA9IDAsXG4gICAgICBjb3VudG91clN0YXJ0WCA9IDAsXG4gICAgICBjb3VudG91clN0YXJ0WSA9IDA7XG4gIHZhciBpLCBqLCBuZXdTZWdtZW50cztcblxuICBpZiAoIWtlZXBMYXp5U3RhY2spIHtcbiAgICB0aGlzLl9fZXZhbHVhdGVTdGFjaygpO1xuICB9XG5cbiAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAocywgaW5kZXgpIHtcblxuICAgIHZhciByZXMgPSBpdGVyYXRvcihzLCBpbmRleCwgbGFzdFgsIGxhc3RZKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHtcbiAgICAgIHJlcGxhY2VtZW50c1tpbmRleF0gPSByZXM7XG4gICAgICBuZWVkUmVwbGFjZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVsYXRpdmUgPSAoc1swXSA9PT0gc1swXS50b0xvd2VyQ2FzZSgpKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBhYnNvbHV0ZSBYIGFuZCBZXG4gICAgc3dpdGNoIChzWzBdKSB7XG4gICAgICBjYXNlICdtJzpcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICBsYXN0WCA9IHNbMV0gKyAoaXNSZWxhdGl2ZSA/IGxhc3RYIDogMCk7XG4gICAgICAgIGxhc3RZID0gc1syXSArIChpc1JlbGF0aXZlID8gbGFzdFkgOiAwKTtcbiAgICAgICAgY291bnRvdXJTdGFydFggPSBsYXN0WDtcbiAgICAgICAgY291bnRvdXJTdGFydFkgPSBsYXN0WTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdoJzpcbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICBsYXN0WCA9IHNbMV0gKyAoaXNSZWxhdGl2ZSA/IGxhc3RYIDogMCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAndic6XG4gICAgICBjYXNlICdWJzpcbiAgICAgICAgbGFzdFkgPSBzWzFdICsgKGlzUmVsYXRpdmUgPyBsYXN0WSA6IDApO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ3onOlxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIC8vIFRoYXQgbWFrZSBzZW5jZSBmb3IgbXVsdGlwbGUgY29udG91cnNcbiAgICAgICAgbGFzdFggPSBjb3VudG91clN0YXJ0WDtcbiAgICAgICAgbGFzdFkgPSBjb3VudG91clN0YXJ0WTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsYXN0WCA9IHNbcy5sZW5ndGggLSAyXSArIChpc1JlbGF0aXZlID8gbGFzdFggOiAwKTtcbiAgICAgICAgbGFzdFkgPSBzW3MubGVuZ3RoIC0gMV0gKyAoaXNSZWxhdGl2ZSA/IGxhc3RZIDogMCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBSZXBsYWNlIHNlZ21lbnRzIGlmIGl0ZXJhdG9yIHJldHVybiByZXN1bHRzXG5cbiAgaWYgKCFuZWVkUmVwbGFjZSkgeyByZXR1cm4gdGhpczsgfVxuXG4gIG5ld1NlZ21lbnRzID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudHNbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgcmVwbGFjZW1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG5ld1NlZ21lbnRzLnB1c2gocmVwbGFjZW1lbnRzW2ldW2pdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U2VnbWVudHMucHVzaChzZWdtZW50c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zZWdtZW50cyA9IG5ld1NlZ21lbnRzO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBDb252ZXJ0cyBzZWdtZW50cyBmcm9tIHJlbGF0aXZlIHRvIGFic29sdXRlXG4vL1xuU3ZnUGF0aC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuaXRlcmF0ZShmdW5jdGlvbiAocywgaW5kZXgsIHgsIHkpIHtcbiAgICB2YXIgbmFtZSA9IHNbMF0sXG4gICAgICAgIG5hbWVVQyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgaTtcblxuICAgIC8vIFNraXAgYWJzb2x1dGUgY29tbWFuZHNcbiAgICBpZiAobmFtZSA9PT0gbmFtZVVDKSB7IHJldHVybjsgfVxuXG4gICAgc1swXSA9IG5hbWVVQztcblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAndic6XG4gICAgICAgIC8vIHYgaGFzIHNoaWZ0ZWQgY29vcmRzIHBhcml0eVxuICAgICAgICBzWzFdICs9IHk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIEFSQyBpczogWydBJywgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxuICAgICAgICAvLyB0b3VjaCB4LCB5IG9ubHlcbiAgICAgICAgc1s2XSArPSB4O1xuICAgICAgICBzWzddICs9IHk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzW2ldICs9IGkgJSAyID8geCA6IHk7IC8vIG9kZCB2YWx1ZXMgYXJlIFgsIGV2ZW4gLSBZXG4gICAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBDb252ZXJ0cyBzZWdtZW50cyBmcm9tIGFic29sdXRlIHRvIHJlbGF0aXZlXG4vL1xuU3ZnUGF0aC5wcm90b3R5cGUucmVsID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuaXRlcmF0ZShmdW5jdGlvbiAocywgaW5kZXgsIHgsIHkpIHtcbiAgICB2YXIgbmFtZSA9IHNbMF0sXG4gICAgICAgIG5hbWVMQyA9IG5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgaTtcblxuICAgIC8vIFNraXAgcmVsYXRpdmUgY29tbWFuZHNcbiAgICBpZiAobmFtZSA9PT0gbmFtZUxDKSB7IHJldHVybjsgfVxuXG4gICAgLy8gRG9uJ3QgdG91Y2ggdGhlIGZpcnN0IE0gdG8gYXZvaWQgcG90ZW50aWFsIGNvbmZ1c2lvbnMuXG4gICAgaWYgKGluZGV4ID09PSAwICYmIG5hbWUgPT09ICdNJykgeyByZXR1cm47IH1cblxuICAgIHNbMF0gPSBuYW1lTEM7XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAvLyBWIGhhcyBzaGlmdGVkIGNvb3JkcyBwYXJpdHlcbiAgICAgICAgc1sxXSAtPSB5O1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAvLyBBUkMgaXM6IFsnQScsIHJ4LCByeSwgeC1heGlzLXJvdGF0aW9uLCBsYXJnZS1hcmMtZmxhZywgc3dlZXAtZmxhZywgeCwgeV1cbiAgICAgICAgLy8gdG91Y2ggeCwgeSBvbmx5XG4gICAgICAgIHNbNl0gLT0geDtcbiAgICAgICAgc1s3XSAtPSB5O1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc1tpXSAtPSBpICUgMiA/IHggOiB5OyAvLyBvZGQgdmFsdWVzIGFyZSBYLCBldmVuIC0gWVxuICAgICAgICB9XG4gICAgfVxuICB9LCB0cnVlKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gQ29udmVydHMgYXJjcyB0byBjdWJpYyBiw6l6aWVyIGN1cnZlc1xuLy9cblN2Z1BhdGgucHJvdG90eXBlLnVuYXJjID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLml0ZXJhdGUoZnVuY3Rpb24gKHMsIGluZGV4LCB4LCB5KSB7XG4gICAgdmFyIG5ld19zZWdtZW50cywgbmV4dFgsIG5leHRZLCByZXN1bHQgPSBbXSwgbmFtZSA9IHNbMF07XG5cbiAgICAvLyBTa2lwIGFueXRoaW5nIGV4Y2VwdCBhcmNzXG4gICAgaWYgKG5hbWUgIT09ICdBJyAmJiBuYW1lICE9PSAnYScpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIGlmIChuYW1lID09PSAnYScpIHtcbiAgICAgIC8vIGNvbnZlcnQgcmVsYXRpdmUgYXJjIGNvb3JkaW5hdGVzIHRvIGFic29sdXRlXG4gICAgICBuZXh0WCA9IHggKyBzWzZdO1xuICAgICAgbmV4dFkgPSB5ICsgc1s3XTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFggPSBzWzZdO1xuICAgICAgbmV4dFkgPSBzWzddO1xuICAgIH1cblxuICAgIG5ld19zZWdtZW50cyA9IGEyYyh4LCB5LCBuZXh0WCwgbmV4dFksIHNbNF0sIHNbNV0sIHNbMV0sIHNbMl0sIHNbM10pO1xuXG4gICAgLy8gRGVnZW5lcmF0ZWQgYXJjcyBjYW4gYmUgaWdub3JlZCBieSByZW5kZXJlciwgYnV0IHNob3VsZCBub3QgYmUgZHJvcHBlZFxuICAgIC8vIHRvIGF2b2lkIGNvbGxpc2lvbnMgd2l0aCBgUyBBIFNgIGFuZCBzbyBvbi4gUmVwbGFjZSB3aXRoIGVtcHR5IGxpbmUuXG4gICAgaWYgKG5ld19zZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbIFsgc1swXSA9PT0gJ2EnID8gJ2wnIDogJ0wnLCBzWzZdLCBzWzddIF0gXTtcbiAgICB9XG5cbiAgICBuZXdfc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgcmVzdWx0LnB1c2goWyAnQycsIHNbMl0sIHNbM10sIHNbNF0sIHNbNV0sIHNbNl0sIHNbN10gXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gQ29udmVydHMgc21vb3RoIGN1cnZlcyAod2l0aCBtaXNzZWQgY29udHJvbCBwb2ludCkgdG8gZ2VuZXJpYyBjdXJ2ZXNcbi8vXG5TdmdQYXRoLnByb3RvdHlwZS51bnNob3J0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICB2YXIgcHJldkNvbnRyb2xYLCBwcmV2Q29udHJvbFksIHByZXZTZWdtZW50O1xuICB2YXIgY3VyQ29udHJvbFgsIGN1ckNvbnRyb2xZO1xuXG4gIC8vIFRPRE86IGFkZCBsYXp5IGV2YWx1YXRpb24gZmxhZyB3aGVuIHJlbGF0aXZlIGNvbW1hbmRzIHN1cHBvcnRlZFxuXG4gIHRoaXMuaXRlcmF0ZShmdW5jdGlvbiAocywgaWR4LCB4LCB5KSB7XG4gICAgdmFyIG5hbWUgPSBzWzBdLCBuYW1lVUMgPSBuYW1lLnRvVXBwZXJDYXNlKCksIGlzUmVsYXRpdmU7XG5cbiAgICAvLyBGaXJzdCBjb21tYW5kIE1VU1QgYmUgTXxtLCBpdCdzIHNhZmUgdG8gc2tpcC5cbiAgICAvLyBQcm90ZWN0IGZyb20gYWNjZXNzIHRvIFstMV0gZm9yIHN1cmUuXG4gICAgaWYgKCFpZHgpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAobmFtZVVDID09PSAnVCcpIHsgLy8gcXVhZHJhdGljIGN1cnZlXG4gICAgICBpc1JlbGF0aXZlID0gKG5hbWUgPT09ICd0Jyk7XG5cbiAgICAgIHByZXZTZWdtZW50ID0gc2VnbWVudHNbaWR4IC0gMV07XG5cbiAgICAgIGlmIChwcmV2U2VnbWVudFswXSA9PT0gJ1EnKSB7XG4gICAgICAgIHByZXZDb250cm9sWCA9IHByZXZTZWdtZW50WzFdIC0geDtcbiAgICAgICAgcHJldkNvbnRyb2xZID0gcHJldlNlZ21lbnRbMl0gLSB5O1xuICAgICAgfSBlbHNlIGlmIChwcmV2U2VnbWVudFswXSA9PT0gJ3EnKSB7XG4gICAgICAgIHByZXZDb250cm9sWCA9IHByZXZTZWdtZW50WzFdIC0gcHJldlNlZ21lbnRbM107XG4gICAgICAgIHByZXZDb250cm9sWSA9IHByZXZTZWdtZW50WzJdIC0gcHJldlNlZ21lbnRbNF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2Q29udHJvbFggPSAwO1xuICAgICAgICBwcmV2Q29udHJvbFkgPSAwO1xuICAgICAgfVxuXG4gICAgICBjdXJDb250cm9sWCA9IC1wcmV2Q29udHJvbFg7XG4gICAgICBjdXJDb250cm9sWSA9IC1wcmV2Q29udHJvbFk7XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICBjdXJDb250cm9sWCArPSB4O1xuICAgICAgICBjdXJDb250cm9sWSArPSB5O1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50c1tpZHhdID0gW1xuICAgICAgICBpc1JlbGF0aXZlID8gJ3EnIDogJ1EnLFxuICAgICAgICBjdXJDb250cm9sWCwgY3VyQ29udHJvbFksXG4gICAgICAgIHNbMV0sIHNbMl1cbiAgICAgIF07XG5cbiAgICB9IGVsc2UgaWYgKG5hbWVVQyA9PT0gJ1MnKSB7IC8vIGN1YmljIGN1cnZlXG4gICAgICBpc1JlbGF0aXZlID0gKG5hbWUgPT09ICdzJyk7XG5cbiAgICAgIHByZXZTZWdtZW50ID0gc2VnbWVudHNbaWR4IC0gMV07XG5cbiAgICAgIGlmIChwcmV2U2VnbWVudFswXSA9PT0gJ0MnKSB7XG4gICAgICAgIHByZXZDb250cm9sWCA9IHByZXZTZWdtZW50WzNdIC0geDtcbiAgICAgICAgcHJldkNvbnRyb2xZID0gcHJldlNlZ21lbnRbNF0gLSB5O1xuICAgICAgfSBlbHNlIGlmIChwcmV2U2VnbWVudFswXSA9PT0gJ2MnKSB7XG4gICAgICAgIHByZXZDb250cm9sWCA9IHByZXZTZWdtZW50WzNdIC0gcHJldlNlZ21lbnRbNV07XG4gICAgICAgIHByZXZDb250cm9sWSA9IHByZXZTZWdtZW50WzRdIC0gcHJldlNlZ21lbnRbNl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2Q29udHJvbFggPSAwO1xuICAgICAgICBwcmV2Q29udHJvbFkgPSAwO1xuICAgICAgfVxuXG4gICAgICBjdXJDb250cm9sWCA9IC1wcmV2Q29udHJvbFg7XG4gICAgICBjdXJDb250cm9sWSA9IC1wcmV2Q29udHJvbFk7XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICBjdXJDb250cm9sWCArPSB4O1xuICAgICAgICBjdXJDb250cm9sWSArPSB5O1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50c1tpZHhdID0gW1xuICAgICAgICBpc1JlbGF0aXZlID8gJ2MnIDogJ0MnLFxuICAgICAgICBjdXJDb250cm9sWCwgY3VyQ29udHJvbFksXG4gICAgICAgIHNbMV0sIHNbMl0sIHNbM10sIHNbNF1cbiAgICAgIF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdmdQYXRoO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/svgpath/lib/svgpath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/svgpath/lib/transform_parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/svgpath/lib/transform_parse.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n\nvar Matrix = __webpack_require__(/*! ./matrix */ \"(ssr)/./node_modules/svgpath/lib/matrix.js\");\n\nvar operations = {\n  matrix: true,\n  scale: true,\n  rotate: true,\n  translate: true,\n  skewX: true,\n  skewY: true\n};\n\nvar CMD_SPLIT_RE    = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\nvar PARAMS_SPLIT_RE = /[\\s,]+/;\n\n\nmodule.exports = function transformParse(transformString) {\n  var matrix = new Matrix();\n  var cmd, params;\n\n  // Split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate',  '-45', '']\n  transformString.split(CMD_SPLIT_RE).forEach(function (item) {\n\n    // Skip empty elements\n    if (!item.length) { return; }\n\n    // remember operation\n    if (typeof operations[item] !== 'undefined') {\n      cmd = item;\n      return;\n    }\n\n    // extract params & att operation to matrix\n    params = item.split(PARAMS_SPLIT_RE).map(function (i) {\n      return +i || 0;\n    });\n\n    // If params count is not correct - ignore command\n    switch (cmd) {\n      case 'matrix':\n        if (params.length === 6) {\n          matrix.matrix(params);\n        }\n        return;\n\n      case 'scale':\n        if (params.length === 1) {\n          matrix.scale(params[0], params[0]);\n        } else if (params.length === 2) {\n          matrix.scale(params[0], params[1]);\n        }\n        return;\n\n      case 'rotate':\n        if (params.length === 1) {\n          matrix.rotate(params[0], 0, 0);\n        } else if (params.length === 3) {\n          matrix.rotate(params[0], params[1], params[2]);\n        }\n        return;\n\n      case 'translate':\n        if (params.length === 1) {\n          matrix.translate(params[0], 0);\n        } else if (params.length === 2) {\n          matrix.translate(params[0], params[1]);\n        }\n        return;\n\n      case 'skewX':\n        if (params.length === 1) {\n          matrix.skewX(params[0]);\n        }\n        return;\n\n      case 'skewY':\n        if (params.length === 1) {\n          matrix.skewY(params[0]);\n        }\n        return;\n    }\n  });\n\n  return matrix;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvdHJhbnNmb3JtX3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7QUFHYixhQUFhLG1CQUFPLENBQUMsNERBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NvdW5kYm9hcmQvLi9ub2RlX21vZHVsZXMvc3ZncGF0aC9saWIvdHJhbnNmb3JtX3BhcnNlLmpzPzg0ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBNYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG52YXIgb3BlcmF0aW9ucyA9IHtcbiAgbWF0cml4OiB0cnVlLFxuICBzY2FsZTogdHJ1ZSxcbiAgcm90YXRlOiB0cnVlLFxuICB0cmFuc2xhdGU6IHRydWUsXG4gIHNrZXdYOiB0cnVlLFxuICBza2V3WTogdHJ1ZVxufTtcblxudmFyIENNRF9TUExJVF9SRSAgICA9IC9cXHMqKG1hdHJpeHx0cmFuc2xhdGV8c2NhbGV8cm90YXRlfHNrZXdYfHNrZXdZKVxccypcXChcXHMqKC4rPylcXHMqXFwpW1xccyxdKi87XG52YXIgUEFSQU1TX1NQTElUX1JFID0gL1tcXHMsXSsvO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtUGFyc2UodHJhbnNmb3JtU3RyaW5nKSB7XG4gIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gIHZhciBjbWQsIHBhcmFtcztcblxuICAvLyBTcGxpdCB2YWx1ZSBpbnRvIFsnJywgJ3RyYW5zbGF0ZScsICcxMCA1MCcsICcnLCAnc2NhbGUnLCAnMicsICcnLCAncm90YXRlJywgICctNDUnLCAnJ11cbiAgdHJhbnNmb3JtU3RyaW5nLnNwbGl0KENNRF9TUExJVF9SRSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXG4gICAgLy8gU2tpcCBlbXB0eSBlbGVtZW50c1xuICAgIGlmICghaXRlbS5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyByZW1lbWJlciBvcGVyYXRpb25cbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbnNbaXRlbV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjbWQgPSBpdGVtO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgcGFyYW1zICYgYXR0IG9wZXJhdGlvbiB0byBtYXRyaXhcbiAgICBwYXJhbXMgPSBpdGVtLnNwbGl0KFBBUkFNU19TUExJVF9SRSkubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gK2kgfHwgMDtcbiAgICB9KTtcblxuICAgIC8vIElmIHBhcmFtcyBjb3VudCBpcyBub3QgY29ycmVjdCAtIGlnbm9yZSBjb21tYW5kXG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSA2KSB7XG4gICAgICAgICAgbWF0cml4Lm1hdHJpeChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG1hdHJpeC5zY2FsZShwYXJhbXNbMF0sIHBhcmFtc1swXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIG1hdHJpeC5zY2FsZShwYXJhbXNbMF0sIHBhcmFtc1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG1hdHJpeC5yb3RhdGUocGFyYW1zWzBdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgbWF0cml4LnJvdGF0ZShwYXJhbXNbMF0sIHBhcmFtc1sxXSwgcGFyYW1zWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShwYXJhbXNbMF0sIDApO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBhcmFtc1swXSwgcGFyYW1zWzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ3NrZXdYJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBtYXRyaXguc2tld1gocGFyYW1zWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBtYXRyaXguc2tld1kocGFyYW1zWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbWF0cml4O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/svgpath/lib/transform_parse.js\n");

/***/ })

};
;